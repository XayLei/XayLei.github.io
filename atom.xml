<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XayLei&#39;s blog</title>
  
  <subtitle>Practice more!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-04T14:46:53.074Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>XayLei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Plain Old Data</title>
    <link href="http://yoursite.com/2019/07/04/Plain-Old-Data/"/>
    <id>http://yoursite.com/2019/07/04/Plain-Old-Data/</id>
    <published>2019-07-04T14:31:19.000Z</published>
    <updated>2019-07-04T14:46:53.074Z</updated>
    
    <content type="html"><![CDATA[<p>POD，全称<strong>plain old data</strong>，plain代表它是一个普通类型，old代表它可以与c兼容，可以使用比如memcpy()这类c中最原始函数进行操作。C++11中把POD分为了两个基本概念的集合，即：平凡的（trival）和标准布局的（standard layout）。</p><p><strong>trival</strong>：通常一个trival的类或者结构体需要满足以下定义，拥有平凡的默认构造函数和析构函数。</p><p>默认的意思就是由编译器为我们自动生成的，不许是我们自己定义的，但是由于c++11提供了default，也可以是自己定义的加=default，比如</p><pre><code>struct Trival{    Trival(){}=default;}</code></pre><p>就是满足这个要求的，而</p><pre><code>struct noTrival{    noTrival(){};}</code></pre><p>就不满足这个要求(哪怕我们定义的构造函数体里面啥都没有）。这个要求对于带参的构造函数没有束缚。你可以自定义带参的构造函数。</p><ul><li>拥有平凡的拷贝构造函数和移动构造函数。默认的意思同上，也可以使用=default。</li><li>拥有平凡的拷贝赋值操作符和移动赋值操作符。</li><li>不能包含虚函数和虚基类。</li></ul><p><strong>standard-layout</strong></p><ul><li>所有非静态成员拥有相同的访问级别，（访问级别就是public，private，protected）</li><li><p>在类和结构体继承时需要满足以下两个情况之一：</p><pre><code>1、派生类中有非静态类，那么这个派生类只能有且只有一个仅包含了静态成员的基类。2、基类有非静态成员，那么派生类中不允许有非静态成员。</code></pre></li><li>类中第一个非静态类型与基类不是同一个类型</li><li>没有虚类和虚基类</li><li>所有非静态数据成员都符合标准布局的要求，这其实就是一个递归的定义。</li></ul><p>C++11中，POD就是满足<strong>trival</strong>和<strong>standard-layout</strong>这两个方面。可以使用<type_traits>中的is_pod<t>::value判断T是不是POD类型的。</t></type_traits></p><h3 id="为什么需要POD这种条件满足的数据呢？"><a href="#为什么需要POD这种条件满足的数据呢？" class="headerlink" title="为什么需要POD这种条件满足的数据呢？"></a>为什么需要POD这种条件满足的数据呢？</h3><ul><li>可以使用字节赋值，比如memset，memcpy操作</li><li>对C内存布局兼容。</li><li>保证了静态初始化的安全有效。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;POD，全称&lt;strong&gt;plain old data&lt;/strong&gt;，plain代表它是一个普通类型，old代表它可以与c兼容，可以使用比如memcpy()这类c中最原始函数进行操作。C++11中把POD分为了两个基本概念的集合，即：平凡的（trival）和标准布局的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GDB调试</title>
    <link href="http://yoursite.com/2019/06/30/GDB%E8%B0%83%E8%AF%95/"/>
    <id>http://yoursite.com/2019/06/30/GDB调试/</id>
    <published>2019-06-30T03:24:19.000Z</published>
    <updated>2019-06-30T12:08:17.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是GDB"><a href="#一、什么是GDB" class="headerlink" title="一、什么是GDB"></a>一、什么是GDB</h2><p>gdb是GNU debugger的缩写，是编程调试工具。</p><p>功能：</p><ul><li><p>启动程序，可以按照用户自定义的要求随心所欲的运行程序。</p></li><li><p>可让被调试的程序在用户所指定的调试断点处停住（断点可以是条件表达式）。</p></li><li><p>当程序停住时，可以检查此时程序中所发生的事。比如，可以打印变量的值。</p></li><li><p>动态改变变量程序的执行环境。</p></li></ul><h2 id="二、段错误"><a href="#二、段错误" class="headerlink" title="二、段错误"></a>二、段错误</h2><p>段错误是由于访问非法地址而产生的错误。</p><p>产生原因：</p><p>1.内存访问越界</p><p> a) 由于使用错误的下标，导致数组访问越界</p><p> b) 搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符</p><p> c) 使用strcpy, strcat, sprintf, strcmp, strcasecmp等字符串操作函数，将目标字符串读/写爆。应该使用strncpy, strlcpy, strncat, strlcat, snprintf, strncmp, strncasecmp等函数防止读写越界。</p><p>2 多线程程序使用了线程不安全的函数。</p><p>3 多线程读写的数据未加锁保护。对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成core dump</p><p>4 非法指针</p><p>a) 使用空指针</p><p>b) 随意使用指针转换。一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，或者这种结构或类型的数组，否则不要将它转换为这种结构或类型 的指针，而应该将这段内存拷贝到一个这种结构或类型中，再访问这个结构或类型。这是因为如果这段内存的开始地址不是按照这种结构或类型对齐的，那么访问它 时就很容易因为bus error而core dump.</p><p>5 堆栈溢出.不要使用大的局部变量（因为局部变量都分配在栈上），这样容易造成堆栈溢出，破坏系统的栈和堆结构，导致出现莫名其妙的错误。</p><h2 id="三、core文件"><a href="#三、core文件" class="headerlink" title="三、core文件"></a>三、core文件</h2><p>在程序崩溃时，一般会生成一个文件叫core文件。core文件记录的是程序崩溃时的内存映像，并加入调试信息，core文件生成过程叫做core dump（核心已转储）。系统默认不会生成该文件。</p><p>发生core dump之后, 用gdb进行查看core文件的内容, 以定位文件中引发core dump的行.</p><pre><code>gdb [exec file] [core file]</code></pre><p>进入gdb后, 用bt命令查看backtrace以检查发生程序运行到哪里, 来定位core文件-&gt;行.</p><p>GDB中键入where，也会看到程序崩溃时堆栈信息（当前函数之前的所有已调用函数的列表（包括当前函数），gdb只显示最近几个）</p><h2 id="四、配置"><a href="#四、配置" class="headerlink" title="四、配置"></a>四、配置</h2><p>1、可以将core文件统一生成到/corefile目录下，产生的文件名为core-命令名-pid-时间戳</p><pre><code>sudo sh -c &apos;echo &quot;/corefile/core-%e-%p-%t&quot; &gt;/proc/sys/kernel/core_pattern&apos;</code></pre><p>%p - insert pid into filename 添加pid</p><p>%u - insert current uid into filename 添加当前uid</p><p>%g - insert current gid into filename 添加当前gid</p><p>%s - insert signal that caused the coredump into the filename 添加导致产生core的信号</p><p>%t - insert UNIX time that the coredump occurred into filename 添加core文件生成的unix时间</p><p>%h - insert hostname where the coredump happened into filename 添加主机名</p><p>%e - insert coredumping executable name into filename 添加命令名</p><p>2、/proc/sys/kernel/core_uses_pid可以控制core文件的问价名是否添加PID作为扩展，文件的内容为1，标识添加PID作为扩展，生成的core文件格式为core.XXXX;为0则表示生成的core文件统一命名为core</p><pre><code>sudo sh -c &apos;echo &quot;1&quot; &gt; /proc/sys/kernel/core_uses_pid&apos;</code></pre><p>3、在.bash_profile和/etc/profile文件末尾添加</p><pre><code>ulimit -c unlimited</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、什么是GDB&quot;&gt;&lt;a href=&quot;#一、什么是GDB&quot; class=&quot;headerlink&quot; title=&quot;一、什么是GDB&quot;&gt;&lt;/a&gt;一、什么是GDB&lt;/h2&gt;&lt;p&gt;gdb是GNU debugger的缩写，是编程调试工具。&lt;/p&gt;
&lt;p&gt;功能：&lt;/p&gt;
&lt;u
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2019年NO-13WEEK总结</title>
    <link href="http://yoursite.com/2019/03/31/2019%E5%B9%B4NO-13WEEK%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/03/31/2019年NO-13WEEK总结/</id>
    <published>2019-03-31T11:52:47.000Z</published>
    <updated>2019-03-31T12:22:42.898Z</updated>
    
    <content type="html"><![CDATA[<p>开年立的flag最终还是没坚持住，周记停了三周，相当于一个月没写，最近失眠，情绪也不太好，求知欲比较低。基本没学什么东西。唯一值得说的就是把GoogleTest大概看了一遍，有了个大概认识，就这些吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开年立的flag最终还是没坚持住，周记停了三周，相当于一个月没写，最近失眠，情绪也不太好，求知欲比较低。基本没学什么东西。唯一值得说的就是把GoogleTest大概看了一遍，有了个大概认识，就这些吧。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Lua学习随笔</title>
    <link href="http://yoursite.com/2019/03/03/Lua%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/"/>
    <id>http://yoursite.com/2019/03/03/Lua学习随笔/</id>
    <published>2019-03-03T14:29:59.000Z</published>
    <updated>2019-03-06T13:18:53.997Z</updated>
    
    <content type="html"><![CDATA[<p>昨天刚立了FLAG，今天就来还愿了。因为是工作中接触到的，已经用了几次，比较熟悉。昨晚在晚上大概搜了下，看了两个教程，看进去了，今早又看了将近两小时，看到了些基础的东西。</p><p>我是在Windows上练习LUA，所以只用下个软件就可以开始了，非常方便。<a href="http://static.runoob.com/download/LuaForWindows_v5.1.4-46.exe" target="_blank" rel="external">下载入口</a></p><p>下载后安装即可，使用方法就是首先打开SciTE，然后在里面直接敲代码，保存为以lua结尾的文件，按F5就可以看到运行结果了。</p><p>首先是注释，单行注释是</p><pre><code>--单行注释</code></pre><p>多行注释：</p><pre><code>--[[多行注释多行注释--]]</code></pre><p>lua中变量不需要声明类型，默认所有变量都是全局变量，如果需要局部变量，需要使用local显式声明。</p><pre><code>a = 5               -- 全局变量local b = 5         -- 局部变量</code></pre><p>lua中两个点“..”表示对字符串进行连接</p><pre><code>print(&quot;字符串1&quot; .. “字符串2”)   --字符串1字符串2</code></pre><p>Lua可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。</p><pre><code>a, b = 10, 2*x       -- a=10; b=2*x</code></pre><p>当变量与值的个数不一致时：</p><pre><code>a. 变量个数 &gt; 值的个数             按变量个数补足nilb. 变量个数 &lt; 值的个数             多余的值会被忽略</code></pre><p>对 table 的索引使用方括号 []。Lua 也提供了 . 操作。</p><pre><code>t[i]t.i                 -- 当索引为字符串类型时的一种简化写法gettable_event(t,i) -- 采用索引访问本质上是一个类似这样的函数调用</code></pre><p>在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}</p><pre><code>-- 创建一个空的 tablelocal tbl1 = {}-- 直接初始表local tbl2 = {&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;}</code></pre><p>lua中的函数，可以类似变量进行互相赋值</p><pre><code>function factorial1(n)   if n == 0 then       return 1   else       return n * factorial1(n - 1)   endendprint(factorial1(5))factorial2 = factorial1print(factorial2(5))</code></pre><p>boolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是”假”，其他的都为”真”:</p><p>Lua 编程语言中数值for循环语法格式:</p><pre><code>for var=exp1,exp2,exp3 do      &lt;执行体&gt;  end </code></pre><p>var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 “执行体”。exp3 是可选的，如果不指定，默认为1。</p><p>lua有两种for循环，上面是第一种，称为数值for循环，可以理解为正常版for。还有一种是泛型for循环，类似于java中的foreach，利用迭代器实现for循环。</p><pre><code>a = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;}for i, v in ipairs(a) do   print(i, v)end </code></pre><p>i是数组索引值，v是对应索引的数组元素值。ipairs是Lua提供的一个迭代器函数，用来迭代数组。</p><p>Lua 编程语言中 repeat…until 循环语法格式:</p><pre><code>repeat  statementsuntil( condition )</code></pre><p>循环条件判断语句（condition）在循环体末尾部分，所以在条件进行判断前循环体都会执行一次。</p><p>如果条件判断语句（condition）为 false，循环会重新开始执行，直到条件判断语句（condition）为 true 才会停止执行。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>lua函数使用function声明，默认为全局函数，如果要使用局部函数，类似于变量，在前面加个local即可。写法格式和平常的函数一样。lua中的函数可以作为参数传递给函数。</p><h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><p>Lua函数可以返回多个结果值，比如string.find，其返回匹配串”开始和结束的下标”（如果不存在匹配串返回nil）。</p><pre><code>&gt; s, e = string.find(&quot;www.runoob.com&quot;, &quot;runoob&quot;) &gt; print(s, e)--输出结果：5    10</code></pre><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><pre><code>function add(...)    local s = 0    for i, v in ipairs{...} do   --&gt; {...} 表示一个由所有变长参数构成的数组       s = s + v    end    return s  end  print(add(3,4,5,6,7))  ---&gt;25--select(&apos;#&apos;, …) 返回可变参数的长度--select(n, …) 用于访问 n 到 select(&apos;#&apos;,…) 的参数</code></pre><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>lua关系运算符中的不等于是“~=”</p><p>字符串连接符“..”</p><p>“#”返回字符串或表的长度</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天刚立了FLAG，今天就来还愿了。因为是工作中接触到的，已经用了几次，比较熟悉。昨晚在晚上大概搜了下，看了两个教程，看进去了，今早又看了将近两小时，看到了些基础的东西。&lt;/p&gt;
&lt;p&gt;我是在Windows上练习LUA，所以只用下个软件就可以开始了，非常方便。&lt;a href
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2019年NO-9WEEK总结</title>
    <link href="http://yoursite.com/2019/03/02/2019%E5%B9%B4NO-9WEEK%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/03/02/2019年NO-9WEEK总结/</id>
    <published>2019-03-02T12:22:18.000Z</published>
    <updated>2019-03-02T13:06:19.585Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间上班真的是忙，被赶着往前走，短时间内团队需要完成巨量的需求，对的，巨量，你没有看错。这周虽然就只干了两件事，但是白天除了吃饭上厕所接水，空余时间基本都没精力或者是没有欲望去看其余技术知识了。这周就连infoQ网站也只是打开几次简单浏览下有些什么，基本没有点开细看过内容。</p><p>上周说的LeetCode第三题，还是上周日白天简单看了下解题思路，实话说，似懂非懂，为啥这样说呢？因为现在脑子里有印象，但要是让我说出来，还真说不清楚。</p><p>在当当买的两本书，这周也陆续到了，都只翻了前几页，看了下大概。对里面内容挺感兴趣，在网上也看到好多人写了读书笔记，我也坚持啃啃吧，练练牙口。</p><p>今天去加班，中午午休时看了一篇文章，题为<font color="#0099ff"><strong>“为什么你写的代码糟透了？符合这10种情况，说明你不适合编程？”</strong></font>，描述了10种阻碍软件开发工程师成长的情况，读了之后还是挺有感触的，摘抄粘贴到这里，供以后回看。</p><ol><li>如果你对计算机和技术原理缺乏好奇心，那就永远不会成为一名成功的程序员。</li><li>如果你不去培养解决问题的能力，那就永远不会成为一名成功的程序员。</li><li>如果你在面对问题时很容易就放弃，那就永远不会成为一名成功的程序员。</li><li>如果你在解决问题后不会感到兴奋或没有成就感，那就永远不会成为一名成功的程序员。</li><li>如果你对学习感到不耐烦并希望能够快速而轻松地掌握所有东西，那就永远不会成为一名成功的程序员。</li><li>如果你懒于思考，把集中、专注的思考看成是一件苦差事，那就永远不会成为一名成功的程序员。</li><li>如果你希望别人为你考虑，并且不愿意自己去探究细节，那就永远不会成为一名成功的程序员。</li><li>如果你的思维僵化，并且很难保持代码的条理性，那就永远不会成为一名成功的程序员。</li><li>如果你认为编程的最终目标是找到正确的解决方案，而不是一系列解决方案，那就永远不会成为一名成功的程序员</li><li>如果你忽略细节，忽视小事情，那就永远不会成为一名成功的程序员。</li></ol><p>成就感，好奇心，不断学习，细节这些真的是很有感触，虽然我代码没写多少，但对于这些特质很认同，如果没有这些特质，程序猿这行真的是待不长久，或者说是没有成长，浑浑噩噩，只会白白浪费人生。比如昨天刚发现的一个BUG，只是一个变量的一个字母错了，导致的结果就是一个功能无法使用，还浪费了大量的时间来找这个错误。细节真的很重要呀，所以平常基本都复制，很少用键盘一个一个字母打这些名称，太容易出错了，稍不留神就会留一个BUG。</p><p>这周用到LUA，感觉这个写起来真的是很简洁，很有兴趣再深入了解，但最终可能会是不了了之吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这段时间上班真的是忙，被赶着往前走，短时间内团队需要完成巨量的需求，对的，巨量，你没有看错。这周虽然就只干了两件事，但是白天除了吃饭上厕所接水，空余时间基本都没精力或者是没有欲望去看其余技术知识了。这周就连infoQ网站也只是打开几次简单浏览下有些什么，基本没有点开细看过内
      
    
    </summary>
    
      <category term="每周总结" scheme="http://yoursite.com/categories/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>2019年NO-8WEEK总结</title>
    <link href="http://yoursite.com/2019/02/23/2019%E5%B9%B4NO-8WEEK%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/02/23/2019年NO-8WEEK总结/</id>
    <published>2019-02-23T13:35:07.000Z</published>
    <updated>2019-03-02T12:27:27.985Z</updated>
    
    <content type="html"><![CDATA[<p>额….让我回忆下这周都大概干了些什么。</p><p>上周日，把之前说的看到的那个练习编程的电子书看了第一章，用了下午大概2到3小时吧，看了第一章的内容概要，主要就是讲这本书干什么的呀，怎么组织的，应该怎么读，有什么意义之类的。这要是中文的肯定不会用这么久，英语阅读太差了，好多都得查查才能理解意思，好歹是看完了。这本电子书主要就是使用JAVA和C++给一个叫Lox的编程语言写解释器。<a href="http://www.craftinginterpreters.com/index.html" target="_blank" rel="external">入口</a></p><p>之后周内，在网上搜索了解了什么是编译器和解释器，在伯乐在线里面找到了一篇译文，原作者用简单的语言讲解了下什么是解释器，并且用PYTHON实现了一个象征意义的解释器，介绍了解释器中的一些基本概念。看完之后感觉很受用。<a href="http://blog.jobbole.com/88152/" target="_blank" rel="external">这是网址，可以点进去了解</a><br>这篇文章是个系列，名字叫<strong>一起来写个简单的解释器</strong></p><p>还有上周提到的混沌工程，infoQ发出了这个系列的第二篇译文，还没顾上看，在这记着。</p><p><a href="https://www.infoq.cn/article/AsN34J2T9QDXB0s-t9JN" target="_blank" rel="external">Netflix 混沌工程手册 Part 2：混沌工程原则</a></p><p><a href="https://www.infoq.cn/article/jjp0c2bR4*Ulld0wb88r" target="_blank" rel="external">Netflix 混沌工程手册 Part 1：混沌工程简介</a></p><p>LeetCode第三道题，求最长子串长度，想了一半，这周再没顾上看。</p><p>这周还看了阮一峰的两篇博文，一篇是关于持续集成的，一篇是讲底层原理的。公司现在也是在用持续集成、持续部署、持续交付进行版本迭代，一直说CICI的，至此才总算弄清了是个什么玩意儿。另一篇是讲一个数字分别声明为Int 和 Float时，在底层是如何存储的，为什么打印出来不一样，好像是看懂了，但是现在写的时候回想下，还是没印象，搞不清，得多读多理解。</p><p>最近开学，当当有买100减半的活动，买了两本书，《编程珠玑》和《编程语言实现模式》，挤时间看吧，看一点算一点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;额….让我回忆下这周都大概干了些什么。&lt;/p&gt;
&lt;p&gt;上周日，把之前说的看到的那个练习编程的电子书看了第一章，用了下午大概2到3小时吧，看了第一章的内容概要，主要就是讲这本书干什么的呀，怎么组织的，应该怎么读，有什么意义之类的。这要是中文的肯定不会用这么久，英语阅读太差了，
      
    
    </summary>
    
      <category term="每周总结" scheme="http://yoursite.com/categories/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>2019年NO.7WEEK总结</title>
    <link href="http://yoursite.com/2019/02/16/2019%E5%B9%B4NO-7WEEK%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/02/16/2019年NO-7WEEK总结/</id>
    <published>2019-02-16T13:37:00.000Z</published>
    <updated>2019-03-02T12:27:27.022Z</updated>
    
    <content type="html"><![CDATA[<p>上周说了要思考今年的计划，但是每天一下班回来都9点了，虽然与大厂比下班够早了，但还是没有一回来就立即学习或码字的冲动，电视跟前坐个大概三、四十分钟，开电脑玩两把LOL就差不多11点了。虽然感觉这样不对，但是真的，也说不上累，就是没有要学习的欲望，希望自己能尽快养成习惯，自律起来，不要浪费时间。</p><p>不管写什么，或者写的好不好，心底里是想养成写博客这个习惯的 ，把自己学到的，在脑子里有印象的东西写下来，也算是个开始。一开始就每天坚持都写，我自己觉着都不现实，坚持不下来。那我就先尝试着每周写一次吧，算是对每一周做个总结，都干了些什么，学了些什么。</p><p>工作上的事就不写了。上周，在网上找到了一个博客，有LeetCode所有的详细题解，博主还开了个微信号，关注了以后，可以在微信上很方便的看到所有题的题解。想着下班有空了就看一道，上周把LeetCode上1、2题抽空做了下，在笔记本上用笔撸了一遍。剩下的慢慢刷，愿望是把所有的题都刷一遍。、</p><p>剩下就是在infoQ上看技术新闻，现在大多都是关于云服务，分布式和微服务方面的技术新闻，确实都很火，公司也都在用。看到的印象最深的应该就是一篇关于混沌工程的NETFLIX文章，第一次见识到混沌工程，一种全新的主动测试理念，2010年就提出来了，这都快10年了，自己竟然第一次听说，眼界确实是太窄了，后面还要加强了。</p><p>在GITHUB上浏览到了一个库，里面放了各种编程语言的教学项目，全部都是英文的，准备空余时间照着做一下，并把英文翻译成中文更新到自己的博客上，顺便练练自己的英语。很期待自己能实现这个想法，相信对自己能力的提升帮助会很大。</p><p>对了，还复习了一遍链表逆序的写法，使用三个链表节点引用实现，还有，双向链表没有逆序意义，请不要白痴的问别人逆序的链表是单向链表还是双向链表。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上周说了要思考今年的计划，但是每天一下班回来都9点了，虽然与大厂比下班够早了，但还是没有一回来就立即学习或码字的冲动，电视跟前坐个大概三、四十分钟，开电脑玩两把LOL就差不多11点了。虽然感觉这样不对，但是真的，也说不上累，就是没有要学习的欲望，希望自己能尽快养成习惯，自律
      
    
    </summary>
    
      <category term="每周总结" scheme="http://yoursite.com/categories/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>农历猪年上班前一晚</title>
    <link href="http://yoursite.com/2019/02/10/%E5%86%9C%E5%8E%86%E7%8C%AA%E5%B9%B4%E4%B8%8A%E7%8F%AD%E5%89%8D%E4%B8%80%E6%99%9A/"/>
    <id>http://yoursite.com/2019/02/10/农历猪年上班前一晚/</id>
    <published>2019-02-10T14:08:07.000Z</published>
    <updated>2019-02-10T14:19:23.844Z</updated>
    
    <content type="html"><![CDATA[<p>今天是农历猪年上班前一天，把iPad这害人玩意儿送我爸完了，上班快一年了，闲时间都被这东西浪费了，干脆送出去一了百了，不然一下班连电脑都懒得打开，一直刷视频去了。</p><p>2018年是上班的第一年，前半年净调整心态了，后半年充电的方向也跑偏了好像，闲暇时间净看理财相关的知识了，没几个钱，净做白日梦。今年不能再这样了，得找回当时在学校的想法了，好歹要在BAT这种大厂进去体验两年生活，然后也要去国外工作两年体验一下国外的生活，见见不一样的人和事，这是近5年吧，目标和计划，总不能一直待着养老吧。脑子里只有个大概的目标，还没有具体的充电计划及实施步骤，所以还得在下班时好好想想，做个大概的计划出来，充分利用机会和时间。</p><p>等计划做好了，再来这写出来详细步骤。</p><p>写博客还是要坚持啊，但是写什么呢？每天在公司净做些苦力活，也没啥新的知识可写，这还得仔细想想，不能让博客荒着。</p><p>嗯，今天就这样吧，明天开始上班，加油！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是农历猪年上班前一天，把iPad这害人玩意儿送我爸完了，上班快一年了，闲时间都被这东西浪费了，干脆送出去一了百了，不然一下班连电脑都懒得打开，一直刷视频去了。&lt;/p&gt;
&lt;p&gt;2018年是上班的第一年，前半年净调整心态了，后半年充电的方向也跑偏了好像，闲暇时间净看理财相关
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jupyter_notebook_install</title>
    <link href="http://yoursite.com/2018/07/22/jupyter-notebook-install/"/>
    <id>http://yoursite.com/2018/07/22/jupyter-notebook-install/</id>
    <published>2018-07-22T07:05:22.000Z</published>
    <updated>2018-07-25T14:29:17.346Z</updated>
    
    <content type="html"><![CDATA[<p>在Ubuntu上安装jupyter notebook</p><p>首先将pip更新到最新版，更新pip时会遇到一个问题</p><pre><code>Traceback (most recent call last):File “/usr/bin/pip3”, line 9, infrom pip import main</code></pre><p>解决方法：</p><p>修改 /usr/bin/pip 文件</p><pre><code>from pip import mainif __name__ == &apos;__main__&apos;:    sys.exit(main())</code></pre><p>修改为</p><pre><code>from pip import __main__if __name__ == &apos;__main__&apos;:   sys.exit(__main__._main())</code></pre><p>修改这个文件时，会遇到权限不够无法修改的问题，只需更改pip文件的权限即可</p><pre><code>chmod 777 pip</code></pre><p>然后查看pip版本</p><pre><code>pip --version</code></pre><p>当pip不是最新版时，更新Pip</p><pre><code>pip install --upgrade pip</code></pre><p>然后安装jupyter</p><pre><code>sudo pip install jupyter</code></pre><p>如果需要卸载jupyter时</p><pre><code>pip install pip-autoremovepip-autoremove jupyter -y</code></pre><p>安装成功后，在终端输入</p><pre><code>jupyter notebook</code></pre><p>即可启动浏览器，打开jupyter,使用过程中不能关闭此终端</p><p>当需要使用机器学习各种包时，直接在终端中使用pip安装即可</p><pre><code>sudo pip install numpysudo pip install pandassudo apt-get install python-matplotlibsudo apt-get install python-sklearn</code></pre><p><a href="https://www.cnblogs.com/tademeng/p/7451125.html" target="_blank" rel="external">关于在ubuntu平台下使用apt-get命令下载速度太慢的问题解决</a></p><p>入门使用：</p><p>选择合适的文件夹，然后点击右上角new，选择Python2，打开一个cell，正确命名，即可开始使用</p><p>关闭时，在终端中敲Ctrl+C，按提示退出，即可关闭jupyter服务器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Ubuntu上安装jupyter notebook&lt;/p&gt;
&lt;p&gt;首先将pip更新到最新版，更新pip时会遇到一个问题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Traceback (most recent call last):
File “/usr/bin/pip3”, line
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>tensorflow相关问题</title>
    <link href="http://yoursite.com/2018/07/01/tensorflow%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/07/01/tensorflow相关问题/</id>
    <published>2018-07-01T05:12:16.000Z</published>
    <updated>2018-07-06T13:29:02.467Z</updated>
    
    <content type="html"><![CDATA[<p>如何安装TensorFlow呢？官方文档写的很清楚，可以参考官方文档。但是安装过程中也会出现一些问题，在这里记录一下。</p><p>我是在虚拟机里装了个64位的Ubuntu虚拟机，强烈建议在linux上玩TensorFlow，方便。我是按照官方推荐的VirtualEnv方法安装的。</p><p>在安装到</p><pre><code>(tensorflow)$ pip install --upgrade &lt;$url_to_binary.whl&gt;</code></pre><p>这一步时，要记着将$url_to_binary.whl用实际的链接代替。</p><p>我用的是</p><pre><code>pip install --upgrade &apos;https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0-cp27-none-linux_x86_64.whl&apos;</code></pre><p>后面到</p><pre><code>cd tensorflow/models/image/mnist</code></pre><p>这一步时，路径错误，可能每个人使用pip安装的，配置的路径都会存在不同的差异性，所以如果找不到相应的路径，记得仔细查找。</p><p>我的是在</p><pre><code>cd lib/python2.7/site-packages/tensorflow/models/image/mnist</code></pre><p>记着把前面的TensorFlow去掉，不然出错。</p><p>安装完TensorFlow后，前几天在公司代码培训的时候第一次听到了Xunit测试设计模式，Gtest是基于这个模式搭建的一个用于C++测试的框架。还第一次听说了死亡测试，感觉挺神奇的，准备试一下。安装完TensorFlow后，顺便把Gtest也装了。</p><p>安装步骤，参照的下面这个网址，但感觉用起来不太方便，但安装起来非常方便快捷</p><p><a href="https://blog.csdn.net/pegasuswang_/article/details/41484783" target="_blank" rel="external">Gtest install step on ubuntu</a></p><p>下面这个网址介绍了Gtest压缩包中各个文件的作用</p><p><a href="https://www.cnblogs.com/Jessica-jie/p/6705067.html" target="_blank" rel="external">https://www.cnblogs.com/Jessica-jie/p/6705067.html</a></p><p>tensorflow开始步骤：</p><pre><code>$ cd ~/tensorflow$ source bin/activate  # 如果使用 bash(tensorflow)$ deactivate  # 停用 virtualenv</code></pre><p>使用TensorFlow时，进入Python编译环境</p><pre><code>import tensorflow as tftf.__version__  //查看TensorFlow版本tf.__path__  //查询tensorflow安装路径为</code></pre><p>更新TensorFlow</p><pre><code>(tensorflow)$ pip install --upgrade tensorflow  # for Python 2.7(tensorflow)$ pip3 install --upgrade tensorflow # for Python 3.n</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如何安装TensorFlow呢？官方文档写的很清楚，可以参考官方文档。但是安装过程中也会出现一些问题，在这里记录一下。&lt;/p&gt;
&lt;p&gt;我是在虚拟机里装了个64位的Ubuntu虚拟机，强烈建议在linux上玩TensorFlow，方便。我是按照官方推荐的VirtualEnv方
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>博客运行问题及解决</title>
    <link href="http://yoursite.com/2018/07/01/%E5%8D%9A%E5%AE%A2%E8%BF%90%E8%A1%8C%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2018/07/01/博客运行问题及解决/</id>
    <published>2018-07-01T04:36:04.000Z</published>
    <updated>2018-07-01T04:46:06.576Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有更新博客了，昨天写了点东西，hexo d的时候却出错了，不能部署。今天终于解决了，在这里记录一下。</p><p>遇到的第一个问题，hexo d的时候，出现：</p><pre><code>fatal: could not read Username for &apos;https://github.com&apos;: Invalid argumentError: bash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for &apos;https://github.com&apos;: Invalid argument</code></pre><p>解决方法：</p><p>之前在_config.yml中的deploy要改一下，改为：</p><pre><code>deploy: type: git repo:git@github.com:your_github_user_name/your_github_user_name.github.io.git branch: master</code></pre><p>然后重新生成SSH key，并添加到GitHub的账户中，把之前的删掉即可</p><p>生成KEY的命令：</p><pre><code>$ ssh-keygen -t rsa -C greenovia@qq.com（换成你的邮箱地址）</code></pre><p>生成过程中一直回车和yes即可。</p><p>最后会在/c/Users/Administrator/.ssh/id_rsa文件中就生成了公钥，即id_rsa.pub中的内容，将公钥添加入GitHub中即可。</p><p>之后再次hexo d时，又出现新的问题</p><pre><code>Error: Host key verification failed.fatal: Could not read from remote repository.Please make sure you have the correct access rights and the repository exists.</code></pre><p>发现在/c/Users/Administrator/.ssh/文件夹中没有know_hosts文件，执行</p><pre><code>$ ssh git@github.com</code></pre><p>我输入这条命令后，文件夹中就会出现know_hosts文件，并且hexo d成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久没有更新博客了，昨天写了点东西，hexo d的时候却出错了，不能部署。今天终于解决了，在这里记录一下。&lt;/p&gt;
&lt;p&gt;遇到的第一个问题，hexo d的时候，出现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fatal: could not read Username for &amp;ap
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu相关问题</title>
    <link href="http://yoursite.com/2018/06/30/Ubuntu%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/06/30/Ubuntu相关问题/</id>
    <published>2018-06-30T14:04:58.000Z</published>
    <updated>2019-02-10T14:07:04.673Z</updated>
    
    <content type="html"><![CDATA[<p>1、安装Ubuntu虚拟机时，内存需设置为主机内存的1/3，否则容易电脑卡死。</p><p>2、当执行spt-get安装时，出现“无法定位软件包”的提示时，输入：</p><pre><code>sudo apt-get update</code></pre><p>3、当出现无法获得锁 /var/lib/apt/lists/lock - open(11:资源暂时不可用)，输入：</p><pre><code>sudo rm /var/lib/apt/lists/locksudo rm /var/lib/dpkg/lock</code></pre><p>4、实现虚拟机与win主机之间粘贴复制</p><p><a href="https://blog.csdn.net/teacher20133/article/details/54601816" target="_blank" rel="external">https://blog.csdn.net/teacher20133/article/details/54601816</a></p><p>5、在运行sudo apt-get update时出现如下信息：</p><pre><code>Reading package lists... DoneE: Problem executing scripts APT::Update::Post-Invoke-Success&apos;if /usr/bin/test -w /var/cache/app-info -a -e /usr/bin/appstreamcli; then appstreamcli refresh &gt; /dev/null; fi&apos;E: Sub-process returned an error code</code></pre><p>解决方法如下:</p><pre><code>sudo pkill -KILL appstreamcliwget -P /tmp https://launchpad.net/ubuntu/+archive/primary/+files/appstream_0.9.4-1ubuntu1_amd64.deb https://launchpad.net/ubuntu/+archive/primary/+files/libappstream3_0.9.4-1ubuntu1_amd64.debsudo dpkg -i /tmp/appstream_0.9.4-1ubuntu1_amd64.deb /tmp/libappstream3_0.9.4-1ubuntu1_amd64.deb</code></pre><p>执行完上述命令之后再次运行sudo apt-get update就不会再出现上面的错误。</p><pre><code>E: 无法获得锁 /var/cache/apt/archives/lock - open (11: 资源暂时不可用)E: 无法对目录 /var/cache/apt/archives/ 加锁</code></pre><p>解决方法：</p><pre><code>sudo rm /var/cache/apt/archives/locksudo rm /var/lib/dpkg/lock</code></pre><p>更新Ubuntu：</p><pre><code>sudo apt upgradesudo apt autoremove</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、安装Ubuntu虚拟机时，内存需设置为主机内存的1/3，否则容易电脑卡死。&lt;/p&gt;
&lt;p&gt;2、当执行spt-get安装时，出现“无法定位软件包”的提示时，输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3、当
      
    
    </summary>
    
    
      <category term="其余" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BD%99/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://yoursite.com/2017/06/29/%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/06/29/算法/</id>
    <published>2017-06-29T07:44:00.000Z</published>
    <updated>2017-12-01T04:25:29.947Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>算法原理：<br>选择一个起始点V作为当前节点</p><p>1、访问当前节点，并标注为已访问，到下一步</p><p>2、如果存在和当前节点相邻并且还没有被访问的节点U，则将U设为当前节点，返回上一步</p><p>3、如果当前节点没有未被访问的相邻节点，则回溯，回退到上一个当前节点</p><p>上面所说的当前节点用栈来维护，每次访问到的节点入栈，回溯的时候出栈</p><p>伪代码：</p><pre><code>DFS（V）    visited[v] = true;    dosomething(v);    for u in adjecnt_list[v]        if visited[u] == false            DFS(u)</code></pre><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>选择一个起点v放入先进先出队列中</p><p>1、如果队列不为空，弹出队列首元素作为当前节点，执行下一步；如果队列为空，则算法结束</p><p>2、将与当前节点相邻且未被访问的所有节点信息更新，并全部放入队列，继续执行上一步</p><p>伪代码：</p><pre><code>BFS(v):    resetArray(visited,false);    visted[v] = true;    queue.push(v);    while(!queue.isEmpty()){        v = queue.poll();        for u in adjecent_list[v]:            if(visited[u] == false)                dosomething(u);                queue.push(u);    }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;DFS&quot;&gt;&lt;a href=&quot;#DFS&quot; class=&quot;headerlink&quot; title=&quot;DFS&quot;&gt;&lt;/a&gt;DFS&lt;/h3&gt;&lt;p&gt;算法原理：&lt;br&gt;选择一个起始点V作为当前节点&lt;/p&gt;
&lt;p&gt;1、访问当前节点，并标注为已访问，到下一步&lt;/p&gt;
&lt;p&gt;2、如果存在
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-MVC学习笔记</title>
    <link href="http://yoursite.com/2017/06/27/Spring-MVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/06/27/Spring-MVC学习笔记/</id>
    <published>2017-06-27T11:10:05.000Z</published>
    <updated>2017-12-01T04:16:20.728Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-MVC执行流程"><a href="#Spring-MVC执行流程" class="headerlink" title="Spring-MVC执行流程"></a>Spring-MVC执行流程</h3><ol><li>客户端发起request请求</li><li>请求到前端控制器（DispatcherServlet）</li><li>前端控制器请求HandlerMapping根据请求的URL查找Handler</li><li>处理器映射器（HandlerMapping）向前端控制器返回Handler</li><li>前端控制器调用处理器适配器去执行Handler</li><li>处理器适配器（HandlerAdapter）执行Handler，就是平常所说的controler执行</li><li>Handler执行完以后给HandlerAdapter返回ModelAndView</li><li>处理器适配器向前端控制器返回ModelAndView</li><li>前端控制器请求视图解析器（view resolver）进行视图解析</li><li>由视图解析器根据ModelAndView得到实际的view对象，向前端控制器返回view</li><li>前端控制器进行视图渲染，将模型数据填充到request域中</li><li>前端控制器向用户响应结果</li></ol><h3 id="spring-MVC是什么？"><a href="#spring-MVC是什么？" class="headerlink" title="spring-MVC是什么？"></a>spring-MVC是什么？</h3><p>MVC是一种设计模式，通过分离模型、视图与控制器在应用程序中的角色将业务逻辑从界面中解耦。spring-MVC是spring的一个重要模块，它以强大的IOC容器为基础，充分利用容器的特性来简化配置。</p><h3 id="拦截器（Interceptor）"><a href="#拦截器（Interceptor）" class="headerlink" title="拦截器（Interceptor）"></a>拦截器（Interceptor）</h3><p>Spring-MVC中的拦截器相当于JavaEE中的过滤器，用于拦截用户的请求并进行相应的处理。</p><p>如何使用拦截器呢？</p><p>首先是实现HandlerInterceptor接口，然后实现afterCompletion、postHandle、preHandle三个抽象方法，最后再springMVC-servlet.xml中添加拦截器配置。</p><p>1、afterCompletion：在整个视图渲染完毕之后执行方法里面的内容，主要用于释放一些资源</p><p>2、postHandle：在Controller执行之后，视图渲染之前执行方法里面的内容，也就是说postHandle方法可以对Model进行操作</p><p>3、preHandle：在Controller执行之前，执行方法里面的内容，注意该方法是有返回值的，当方法返回false时整个请求就结束了</p><h3 id="springMVC配置"><a href="#springMVC配置" class="headerlink" title="springMVC配置"></a>springMVC配置</h3><p>通过maven创建web工程时，自动创建的web.xml中的文件头中用的servlet版本为2.3，需修改为3.1<br><br>web.xml的3.1版头文件可以在B:\tomcat_9\apache-tomcat-8.0.43\webapps\examples\WEB-INF\web.xml中去复制，也就是到Tomcat的安装路径中去找</p><p>首先是在web.xml中配置前端控制器</p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;          &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;          &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>然后创建springmvc-servlet.xml，配置视图解析器和包扫描</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-4.0.xsd     http://www.springframework.org/schema/mvc     http://www.springframework.org/schema/mvc/spring-mvc.xsd     http://www.springframework.org/schema/context     http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 配置springMVC --&gt;    &lt;!-- 1.开启springMVC注解模式 --&gt;    &lt;mvc:annotation-driven /&gt;    &lt;!--2.静态资源默认servlet配置--&gt;    &lt;!--            1).加入对静态资源处理：js,gif,png            2).允许使用 &quot;/&quot; 做整体映射    --&gt;    &lt;mvc:default-servlet-handler/&gt;    &lt;!--3：配置JSP 显示ViewResolver--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;       &lt;/bean&gt;    &lt;!--4:扫描web相关的bean--&gt;    &lt;context:component-scan base-package=&quot;org.seckill.web&quot;/&gt;&lt;/beans&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring-MVC执行流程&quot;&gt;&lt;a href=&quot;#Spring-MVC执行流程&quot; class=&quot;headerlink&quot; title=&quot;Spring-MVC执行流程&quot;&gt;&lt;/a&gt;Spring-MVC执行流程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;客户端发起request请求&lt;/
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>悲观锁与乐观锁</title>
    <link href="http://yoursite.com/2017/06/26/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/"/>
    <id>http://yoursite.com/2017/06/26/悲观锁与乐观锁/</id>
    <published>2017-06-26T08:27:15.000Z</published>
    <updated>2017-12-01T04:24:40.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库层面的悲观锁与乐观锁"><a href="#数据库层面的悲观锁与乐观锁" class="headerlink" title="数据库层面的悲观锁与乐观锁"></a>数据库层面的悲观锁与乐观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>数据库中，<strong>悲观并发控制</strong>是一种并发控制的方法，这种方法简称是悲观锁。它可以阻止一个事物以影响其他用户的方式来修改数据。如果一个事物的某个操作应用了锁，那只有这个事物把锁释放时，其他事物才能够执行与该锁冲突的操作。</p><p>主要应用于数据争用激烈的场合，以及发生并发冲突时使用锁保护数据的成本低于事物回滚成本的环境中。</p><p>悲观锁实际上是采用了“先取锁再访问”的保守策略，使数据处理更加安全，但是，这样就增加了数据库的开销，而且还有死锁的可能。并且在只读操作中，是不需要加锁的，盲目的加锁只会增加系统的负载。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a><span style="font-family:Comic Sans MS">乐观锁</span></h3><p>乐观锁的全称是乐观并发控制，也是一种并发控制方法。它假设多用户并发的事物在实际操作时不会彼此影响，各个事物能够在不加锁的情况下处理各自影响的那部分数据。</p><p>在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</p><p>可以发现，悲观锁是通过加锁实现并发控制，乐观锁是通过回滚实现并发控制。</p><p>应用场景：与悲观锁正好相反，乐观并发控制多数用于数据争用不大、冲突较少的环境中，这种环境中，偶尔回滚事务的成本会低于读取数据时锁定数据的成本，因此可以获得比其他并发控制方法更高的吞吐量。</p><p>虽然乐观锁减少了数据库的开销和系统的负载，也不会产生死锁，但还是会发生不可预期的结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库层面的悲观锁与乐观锁&quot;&gt;&lt;a href=&quot;#数据库层面的悲观锁与乐观锁&quot; class=&quot;headerlink&quot; title=&quot;数据库层面的悲观锁与乐观锁&quot;&gt;&lt;/a&gt;数据库层面的悲观锁与乐观锁&lt;/h2&gt;&lt;h3 id=&quot;悲观锁&quot;&gt;&lt;a href=&quot;#悲观锁&quot; c
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java杂记</title>
    <link href="http://yoursite.com/2017/06/21/Java%E6%9D%82%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/06/21/Java杂记/</id>
    <published>2017-06-21T14:42:04.000Z</published>
    <updated>2017-12-01T04:20:28.944Z</updated>
    
    <content type="html"><![CDATA[<p><strong>java进制转换：</strong></p><ul><li>java的整型封装类Integer和Long提供<strong>toString（int i,int radix）</strong>静态方法，可以将一个任意进制的整数转换为其他进制的整数。</li><li>使用Integer或Long的<strong>toBinaryString</strong>方法将整数转换为二进制。</li><li>使用Integer或Long的<strong>toOctalString</strong>方法将整数转换为八进制。</li><li>使用Integer或Long的<strong>toHexString</strong>方法将整数转换为十六进制。</li><li>使用Integer或Long的<strong>toString(int i)</strong>方法可以将其他进制的整数转换为十进制的整数的字符串表示</li></ul><h3 id="String类可以继承吗"><a href="#String类可以继承吗" class="headerlink" title="String类可以继承吗"></a>String类可以继承吗</h3><p>String类是被final修饰的，所以不可以被继承；</p><p>为什么要用final修饰String呢？</p><p>1、<strong>Security</strong>: the system can hand out sensitive bits of read-only information without worrying that they will be altered</p><p>2、<strong>Performance</strong>: immutable data is very useful in making things thread-safe.</p><h3 id="String-相关问题"><a href="#String-相关问题" class="headerlink" title="String 相关问题"></a>String 相关问题</h3><p>1、“==”是用来检测俩引用是不是指向内存中的同一个对象，而equals()方法则检测的是两个对象的值是否相等</p><p>2、String、StringBuffer和StringBuilder:</p><ul><li>都是final类，都不允许被继承</li><li>String的长度时不可变的，其它两个的长度是可变的。String是不可变的对象, 因此在每次对String 类型进行改变的时候，都会生成一个<strong>新的 String 对象</strong>，然后将<strong>指针</strong>指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后，JVM 的 GC 就会开始工作，性能就会降低。</li><li>StringBuffer是线程安全的，StringBuilder是线程不安全的</li></ul><p>使用基本原则：如果只是操作少量数据，使用String；如果单线程操作大量数据，选用StringBuilder;如果多线程操作大量数据，选用StringBuffer。</p><p>3、如何使用空格分割字符串：</p><pre><code>String[] strArray = aString.split(&quot;\\s+&quot;);</code></pre><p>4、String c = new String(“java”);这个语句背后的发生过程：</p><ul><li>1）在heap上为String对象申请内存</li><li>2）尝试从常量池中获取“java”字符串，如果常量池中不存在，则在常量池中新建“java”字符串，并返回</li><li>3）调用构造方法，初始化String对象</li></ul><p>java中String对象使用char数组存储字符串，变量c指向Java堆的String对象，且该对象的char数组指向常量池的”java”字符串。</p><p><img src="http://incdn1.b0.upaiyun.com/2016/09/dca37659a4da9a595fe59232a0278414.png" alt=""></p><pre><code>String a = &quot;hello &quot;;String b = &quot;world&quot;;String c = a + b; //字符串变量的连接动作，在编译阶段会被转化成StringBuilder的append操作，变量c最终指向Java堆上新建String对象String d = &quot;hello world&quot;;//变量d指向常量池的”hello world”字符串，所以 c != d。</code></pre><p><a href="http://www.importnew.com/21711.html" target="_blank" rel="external">浅谈java String内幕（上）</a><br><br><a href="http://www.importnew.com/21720.html" target="_blank" rel="external">String.intern()原理</a></p><h3 id="synchronized与ReentrantLock"><a href="#synchronized与ReentrantLock" class="headerlink" title="synchronized与ReentrantLock"></a>synchronized与ReentrantLock</h3><p>ReentrantLock在加锁和提供内存可见性上的功能与内置锁相同。但是，ReentrantLock还有一些其他更灵活的加锁功能，如可定时锁，轮询锁，可中断锁，公平锁和非公平锁，实现非块结构的加锁。其中，定时锁与轮询锁由tryLock()方法实现。可中断锁由lockInterruptibly()方法实现，公平锁与非公平锁可由ReentrantLock的构造函数实现。</p><p>在高并发环境中，ReentrantLock的性能优于内置锁。</p><p>既然ReentrantLock锁这么好，那为什么java还不弃用内置锁呢？</p><p>原因是：内置锁为许多开发人员所熟悉，并且简洁紧凑。ReentrantLock则有一定的危险性，如果在finally块中忘记调用unlock（）方法，则会产生一些潜在的危险。仅当内置锁无法满足需求时，才可以考虑使用ReentrantLock。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;java进制转换：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;java的整型封装类Integer和Long提供&lt;strong&gt;toString（int i,int radix）&lt;/strong&gt;静态方法，可以将一个任意进制的整数转换为其他进制的整数。&lt;/l
      
    
    </summary>
    
      <category term="语法" scheme="http://yoursite.com/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>多线程学习笔记</title>
    <link href="http://yoursite.com/2017/06/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/06/21/多线程学习笔记/</id>
    <published>2017-06-21T14:40:47.000Z</published>
    <updated>2017-12-01T04:23:43.840Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Executor、ExecutorService和Executors"><a href="#Executor、ExecutorService和Executors" class="headerlink" title="Executor、ExecutorService和Executors"></a>Executor、ExecutorService和Executors</h3><p>A：Executor是一个抽象层面的核心接口，将任务的提交过程和执行过程解耦。</p><p>B：ExecutorService对executor接口进行了扩展，添加了一些用于生命周期管理的方法，如返回future对象，终止、关闭线程池等方法。</p><p>A与B的区别：</p><p>1、B是A的子接口</p><p>2、A定义execute（）方法来接收Runnable接口的对象，<br>   B中的submit方法可以接受runnable接口和callable接口的对象</p><p>3、execute方法不返回任何结果，<br>   submit方法可以通过future对象返回运算结果</p><p>4、B提供了管理线程池的方法</p><p>Executors是一个工具类，提供工厂方法来创建不同类型的线程池</p><hr><h3 id="如何正确的停止一个线程："><a href="#如何正确的停止一个线程：" class="headerlink" title="如何正确的停止一个线程："></a>如何正确的停止一个线程：</h3><ul><li>Thread.stop或Thread.susupend(已废弃)</li><li>使用interupt()方法</li><li>使用条件变量</li></ul><p>具体见：</p><blockquote><p><a href="http://ibruce.info/2013/12/19/how-to-stop-a-java-thread/" target="_blank" rel="external">http://ibruce.info/2013/12/19/how-to-stop-a-java-thread/</a></p></blockquote><h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><ol><li>线程是进程的子集，一个进程可以有多个线程，每条线程并行执行不同的任务</li><li>不同的进程拥有不同的内存空间，而所有的线程共享同一块内存空间</li><li>每个线程都有单独的栈内存来存储本地数据</li><li>线程是操作系统能够进行运算调度的最小单位，它被包含在进程中，是进程的实际运作单位</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Executor、ExecutorService和Executors&quot;&gt;&lt;a href=&quot;#Executor、ExecutorService和Executors&quot; class=&quot;headerlink&quot; title=&quot;Executor、ExecutorService
      
    
    </summary>
    
      <category term="语法" scheme="http://yoursite.com/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>B树与B+树</title>
    <link href="http://yoursite.com/2017/06/17/B%E6%A0%91%E4%B8%8EB-%E6%A0%91/"/>
    <id>http://yoursite.com/2017/06/17/B树与B-树/</id>
    <published>2017-06-17T08:47:40.000Z</published>
    <updated>2017-12-01T04:17:08.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="B树与B-树的区别"><a href="#B树与B-树的区别" class="headerlink" title="B树与B+树的区别"></a>B树与B+树的区别</h2><p>B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。</p><p>B+树非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中</p><h3 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h3><p>B+树的内部节点不含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。</p><p>B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。</p><h3 id="B树的优点"><a href="#B树的优点" class="headerlink" title="B树的优点"></a>B树的优点</h3><p>由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;B树与B-树的区别&quot;&gt;&lt;a href=&quot;#B树与B-树的区别&quot; class=&quot;headerlink&quot; title=&quot;B树与B+树的区别&quot;&gt;&lt;/a&gt;B树与B+树的区别&lt;/h2&gt;&lt;p&gt;B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据库索引</title>
    <link href="http://yoursite.com/2017/06/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2017/06/17/数据库索引/</id>
    <published>2017-06-17T06:33:58.000Z</published>
    <updated>2017-12-01T04:23:27.149Z</updated>
    
    <content type="html"><![CDATA[<p>索引是存储引擎用于快速找到记录的一种数据结构。</p><h2 id="索引目的"><a href="#索引目的" class="headerlink" title="索引目的"></a>索引目的</h2><p>索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql</p><h2 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h2><h3 id="索引类别"><a href="#索引类别" class="headerlink" title="索引类别"></a>索引类别</h3><ul><li><p>大多数索引指的是B-树索引，InnoDB索引使用的数据结构是B+Tree</p></li><li><p>MySQL中的MEMORY存储引擎显示支持哈希索引，哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效，存储引擎会对所有的索引列计算一个哈希码，哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。如果哈希值发生冲突，哈希索引会以链表的方式存储多个记录指针到同一个哈希条目中</p></li><li><p>空间数据索引：MyISAM存储引擎支持，无需前缀查询，会从所有维度来索引数据。</p></li></ul><h3 id="磁盘I-O与预读"><a href="#磁盘I-O与预读" class="headerlink" title="磁盘I/O与预读"></a>磁盘I/O与预读</h3><p>磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分：</p><ul><li>寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；</li><li>旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；</li><li>传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。</li></ul><p>那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。</p><p>考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)，也就是读取一页内的数据时候，实际上才发生了一次IO</p><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>B+树是B树的一种变种，B树是一个节点可以拥有超过2个子节点的二叉查找树。</p><p><img src="http://tech.meituan.com/img/mysql_index/btree.jpg" alt=""></p><p>如上图所示，浅蓝色是磁盘块，深蓝色代表数据项，黄色代表指针</p><p>叶子节点存储真实的数据，非叶子节点只存储指引方向的数据项。如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。</p><p>查找过程：</p><p>如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO；</p><p>在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO；</p><p>29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO；</p><p>真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p><h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><ol><li>索引大大减少了服务器需要扫描的数据量</li><li>帮助服务器避免排序和临时表</li><li>可以将随机I/O变为顺序I/O</li></ol><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><p>唯一的索引 (Unique Index)：在表格上面创建某个一个唯一的索引。唯一的索引意味着两个行不能拥有相同的索引值。</p><pre><code>CREATE UNIQUE INDEX 索引名称 ON 表名称 (列名称) </code></pre><p>列名称规定需要索引的列</p><p>简单索引：省略UNIQUE值，这样就可以使用重复的值</p><p>实例：</p><pre><code>CREATE INDEX PersonIndex ON Person (LastName)//索引不止一列时，使用逗号隔开列名CREATE INDEX PersonIndex ON Person (LastName, FirstName)</code></pre><p>参考：</p><blockquote><p><a href="http://tech.meituan.com/mysql-index.html" target="_blank" rel="external">http://tech.meituan.com/mysql-index.html</a></p><p><a href="http://blog.jobbole.com/24006/" target="_blank" rel="external">http://blog.jobbole.com/24006/</a></p></blockquote><hr><h2 id="索引分类："><a href="#索引分类：" class="headerlink" title="索引分类："></a>索引分类：</h2><p>普通索引：创建普通索引时，没有任何限制条件</p><p>唯一性索引：使用UNIQUE关键字创建，主键就是一种特殊的唯一性索引</p><p>全文索引：FULLTEXT，只能创建在CHAR、VARCHAR或TEXT类型的字段上。只有MyISAM存储引擎支持全文检索</p><p>单列索引：在表中的单个字段上创建索引</p><p>多列索引：在表的多个字段创建一个索引</p><p>空间索引：使用SPATIAL参数，空间索引只能建立在空间数据类型上，只有MyISAM存储引擎支持，且索引字段必须非空。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;索引是存储引擎用于快速找到记录的一种数据结构。&lt;/p&gt;
&lt;h2 id=&quot;索引目的&quot;&gt;&lt;a href=&quot;#索引目的&quot; class=&quot;headerlink&quot; title=&quot;索引目的&quot;&gt;&lt;/a&gt;索引目的&lt;/h2&gt;&lt;p&gt;索引的目的在于提高查询效率，可以类比字典，如果要查“mysql
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记</title>
    <link href="http://yoursite.com/2017/06/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/06/14/数据库学习笔记/</id>
    <published>2017-06-14T14:32:30.000Z</published>
    <updated>2017-12-01T04:25:13.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h2><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h3><p>原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。</p><h3 id="2-一致性"><a href="#2-一致性" class="headerlink" title="2.一致性"></a>2.一致性</h3><p>一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</p><h3 id="3-隔离性"><a href="#3-隔离性" class="headerlink" title="3.隔离性"></a>3.隔离性</h3><p>多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</p><p>事务之间的相互影响分为几种，分别为：脏读，不可重复读，幻读，丢失更新</p><p>(1)脏读</p><p>脏读意味着一个事务读取了另一个事务未提交的数据，而这个数据是有可能回滚的</p><p>(2)不可重复读</p><p>不可重复读意味着，在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。</p><p>(3)幻读（虚读）</p><p>幻读，是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.</p><p>(4)丢失更新</p><p>两个事务同时读取同一条记录，A先修改记录，B也修改记录（B是不知道A修改过），B提交数据后B的修改结果覆盖了A的修改结果。</p><h3 id="4-持久性"><a href="#4-持久性" class="headerlink" title="4.持久性"></a>4.持久性</h3><p>持久性，意味着在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p><h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><p><span style="font-family: comic sans ms,sans-serif;"><span style="color: red;">MySQL索引使用的数据结构是B+tree，Oracle及Sysbase的索引使用的是B-Tree</span></span></p><p>索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构</p><ul><li>索引加快数据库的检索速度</li><li>索引降低了插入、删除、修改等维护任务的速度</li><li>唯一索引可以确保每一行数据的唯一性</li><li>索引需要占物理和数据空间</li></ul><h2 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h2><p>事物是并发控制的基本单位</p><p>所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。</p><h2 id="drop、delete与truncate"><a href="#drop、delete与truncate" class="headerlink" title="drop、delete与truncate"></a>drop、delete与truncate</h2><ul><li>速度,一般来说: drop&gt; truncate &gt;delete </li><li>delete和truncate只删除表的数据不删除表的结构</li><li>不再需要一张表的时候，用drop</li><li>删除部分数据行时候，用delete，并且带上where子句</li><li>保留表而删除所有数据的时候用truncate</li></ul><h2 id="超键、候选键、主键、外键"><a href="#超键、候选键、主键、外键" class="headerlink" title="超键、候选键、主键、外键"></a>超键、候选键、主键、外键</h2><p>主键（PRIMARY KEY）：主键必须包含唯一的值，主键列不能包含null值，每个表都应该有一个主键，每个表都只能有一个主键</p><p>在创建表的时候创建主键约束：</p><pre><code>CREATETABLE Persons(    Id_P int NOT NULL,  //声明为主键的列不能有NULL值    LastName varchar(255) NOT NULL,    FirstName varchar(255),    Address varchar(255),    City varchar(255),    PRIMARY KEY (Id_P))//如果在表已存在的情况下为 &quot;Id_P&quot; 列创建 PRIMARY KEY 约束，请使用下面的 SQL：ALTER TABLE Persons ADD PRIMARY KEY (Id_P)//撤销 PRIMARY KEY 约束，请使用下面的 SQLALTER TABLE Persons DROP PRIMARY KEY</code></pre><p>外键：在一个表中存在的另一个表的主键称此表的外键</p><p><a href="http://blog.csdn.net/lfsfxy9/article/details/5949632" target="_blank" rel="external">理解超键、候选键、主键.</a></p><hr><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p><strong>视图既可以由数据库中1个或多个基本表导出，也可以由已存在的视图导出</strong></p><p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查三种操作，视图通常是一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p><p>创建视图：</p><pre><code>CREATE VIEW view_name ASSELECT column_name(s)FROM table_nameWHERE condition</code></pre><p>使用场景：</p><ul><li>当为了安全考虑时，只想要暴露表中的部分字段，这是就可以建一个视图</li><li>查询的数据来源于不同的表，希望以统一的方式查询，这时可以通过建一个视图把多个表的查询结果联合起来，查询者就只需要直接从视图中获取数据即可</li></ul><hr><h2 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h2><p>什么是存储引擎？</p><p>简而言之，存储引擎就是指表的类型，数据库的存储引擎决定了表在计算机中的存储方式。</p><h3 id="InnoDB引擎："><a href="#InnoDB引擎：" class="headerlink" title="InnoDB引擎："></a>InnoDB引擎：</h3><p>优势：提供了良好的事务管理、崩溃修复能力和并发控制，支持外键（FOREIGN KEY）和自增列(AUTO_INCREMENT)</p><p>缺点：读写效率差，占用的数据空间相对较大</p><p>应用场景：对事物完整性的要求较高，要求实现并发控制，需要频繁的更新、删除操作</p><h3 id="MyISAM存储引擎："><a href="#MyISAM存储引擎：" class="headerlink" title="MyISAM存储引擎："></a>MyISAM存储引擎：</h3><p>这种引擎的表存储为三种类型：frm，MYD，MYI，分别存储表的结构，表中数据和表的索引。</p><p>优点：占用空间小，插入数据快</p><p>缺点：不支持事物的完整性和并发性</p><p>应用场景：插入和读出操作频繁</p><h3 id="MEMORY存储引擎："><a href="#MEMORY存储引擎：" class="headerlink" title="MEMORY存储引擎："></a>MEMORY存储引擎：</h3><p>默认使用哈希索引，所有数据都在内存中，使用内存中的内容创建表</p><p>优点：数据处理速度快，</p><p>缺点：安全性不高，数据易丢失，生命周期短，</p><p>适用于创建小型表</p><h3 id="ARCHIVE存储引擎"><a href="#ARCHIVE存储引擎" class="headerlink" title="ARCHIVE存储引擎"></a>ARCHIVE存储引擎</h3><p>拥有很好的压缩机制，仅支持最基本的插入和查询两种功能</p><h3 id="CSV存储引擎"><a href="#CSV存储引擎" class="headerlink" title="CSV存储引擎"></a>CSV存储引擎</h3><p>把数据以逗号分隔的格式存储在文本文件中。</p><h3 id="BLACKHOLE存储引擎"><a href="#BLACKHOLE存储引擎" class="headerlink" title="BLACKHOLE存储引擎"></a>BLACKHOLE存储引擎</h3><p>接受但不存储数据，并且检索总是返回一个空集</p><h3 id="FEDERATED存储引擎"><a href="#FEDERATED存储引擎" class="headerlink" title="FEDERATED存储引擎"></a>FEDERATED存储引擎</h3><p>把数据存在远程数据库中</p><hr><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><strong>DISTINCT</strong> 用于返回唯一不同的值</p><p>MySQL中<strong>BETWEEN</strong>的边界问题：两边都包含，相当于&gt;=和&lt;=</p><p><strong>LIKE</strong>关键字可以匹配字符串是否相等，“%”可以代表任意长度的字符串，“_”只能表示单个字符。在实际使用时，需要匹配的字符串需要加引号，既可以是单引号，也可以是双引号</p><p>连接查询：将两个或两个以上的表按照某个条件连接起来，从中选取需要的数据。<br>分为内连接和外连接，外连接又有左连接和右连接。</p><ul><li>INNER JOIN: 如果表中有至少一个匹配，则返回行</li><li>LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行</li><li>RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行</li><li>FULL JOIN: 只要其中一个表中存在匹配，就返回行</li></ul><hr><h2 id="数据库的四种隔离级别"><a href="#数据库的四种隔离级别" class="headerlink" title="数据库的四种隔离级别"></a>数据库的四种隔离级别</h2><p>在数据库操作中，为了保证并发读取数据的正确性，提出了事物隔离级别概念</p><ul><li>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</li><li>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)</li><li>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读</li><li>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li></ul><h3 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h3><p>为什么需要范式？范式有什么作用？</p><p>范式可以减少数据冗余、消除异常、让数据组织更加和谐。</p><p>数据冗余是指一个字段在多个表中重复出现</p><p>什么是范式？</p><p>范式是为了消除重复数据，减少冗余数据，让数据库中的数据更好的一种组织，让磁盘空间得到有效利用的一种标准化组织</p><p>什么是第一范式？</p><p>第一范式就是每一个属性都不可再分。不符合第一范式则不能称为关系数据库。</p><p>什么是第二范式?</p><p>表中的属性必须完全依赖于全部主键，而不是部分主键.所以只有一个主键的表如果符合第一范式，那一定是第二范式。</p><p>第三范式：3NF是为了消除数据库中关键字之间的依赖关系</p><p>还有BC范式和第四范式。</p><p><a href="http://blog.jobbole.com/92442/" target="_blank" rel="external">参考资料1</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ACID特性&quot;&gt;&lt;a href=&quot;#ACID特性&quot; class=&quot;headerlink&quot; title=&quot;ACID特性&quot;&gt;&lt;/a&gt;ACID特性&lt;/h2&gt;&lt;h3 id=&quot;1-原子性&quot;&gt;&lt;a href=&quot;#1-原子性&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
</feed>
