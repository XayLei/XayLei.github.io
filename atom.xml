<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XayLei&#39;s blog</title>
  
  <subtitle>Practice more!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-06T12:56:05.245Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>XayLei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tensorflow相关问题</title>
    <link href="http://yoursite.com/2018/07/01/tensorflow%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/07/01/tensorflow相关问题/</id>
    <published>2018-07-01T05:12:16.000Z</published>
    <updated>2018-07-06T12:56:05.245Z</updated>
    
    <content type="html"><![CDATA[<p>如何安装TensorFlow呢？官方文档写的很清楚，可以参考官方文档。但是安装过程中也会出现一些问题，在这里记录一下。</p><p>我是在虚拟机里装了个64位的Ubuntu虚拟机，强烈建议在linux上玩TensorFlow，方便。我是按照官方推荐的VirtualEnv方法安装的。</p><p>在安装到</p><pre><code>(tensorflow)$ pip install --upgrade &lt;$url_to_binary.whl&gt;</code></pre><p>这一步时，要记着将$url_to_binary.whl用实际的链接代替。</p><p>我用的是</p><pre><code>pip install --upgrade &apos;https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0-cp27-none-linux_x86_64.whl&apos;</code></pre><p>后面到</p><pre><code>cd tensorflow/models/image/mnist</code></pre><p>这一步时，路径错误，可能每个人使用pip安装的，配置的路径都会存在不同的差异性，所以如果找不到相应的路径，记得仔细查找。</p><p>我的是在</p><pre><code>cd lib/python2.7/site-packages/tensorflow/models/image/mnist</code></pre><p>记着把前面的TensorFlow去掉，不然出错。</p><p>安装完TensorFlow后，前几天在公司代码培训的时候第一次听到了Xunit测试设计模式，Gtest是基于这个模式搭建的一个用于C++测试的框架。还第一次听说了死亡测试，感觉挺神奇的，准备试一下。安装完TensorFlow后，顺便把Gtest也装了。</p><p>安装步骤，参照的下面这个网址，但感觉用起来不太方便，但安装起来非常方便快捷</p><p><a href="https://blog.csdn.net/pegasuswang_/article/details/41484783" target="_blank" rel="external">Gtest install step on ubuntu</a></p><p>下面这个网址介绍了Gtest压缩包中各个文件的作用</p><p><a href="https://www.cnblogs.com/Jessica-jie/p/6705067.html" target="_blank" rel="external">https://www.cnblogs.com/Jessica-jie/p/6705067.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如何安装TensorFlow呢？官方文档写的很清楚，可以参考官方文档。但是安装过程中也会出现一些问题，在这里记录一下。&lt;/p&gt;
&lt;p&gt;我是在虚拟机里装了个64位的Ubuntu虚拟机，强烈建议在linux上玩TensorFlow，方便。我是按照官方推荐的VirtualEnv方
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>博客运行问题及解决</title>
    <link href="http://yoursite.com/2018/07/01/%E5%8D%9A%E5%AE%A2%E8%BF%90%E8%A1%8C%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2018/07/01/博客运行问题及解决/</id>
    <published>2018-07-01T04:36:04.000Z</published>
    <updated>2018-07-01T04:46:06.576Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有更新博客了，昨天写了点东西，hexo d的时候却出错了，不能部署。今天终于解决了，在这里记录一下。</p><p>遇到的第一个问题，hexo d的时候，出现：</p><pre><code>fatal: could not read Username for &apos;https://github.com&apos;: Invalid argumentError: bash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for &apos;https://github.com&apos;: Invalid argument</code></pre><p>解决方法：</p><p>之前在_config.yml中的deploy要改一下，改为：</p><pre><code>deploy: type: git repo:git@github.com:your_github_user_name/your_github_user_name.github.io.git branch: master</code></pre><p>然后重新生成SSH key，并添加到GitHub的账户中，把之前的删掉即可</p><p>生成KEY的命令：</p><pre><code>$ ssh-keygen -t rsa -C greenovia@qq.com（换成你的邮箱地址）</code></pre><p>生成过程中一直回车和yes即可。</p><p>最后会在/c/Users/Administrator/.ssh/id_rsa文件中就生成了公钥，即id_rsa.pub中的内容，将公钥添加入GitHub中即可。</p><p>之后再次hexo d时，又出现新的问题</p><pre><code>Error: Host key verification failed.fatal: Could not read from remote repository.Please make sure you have the correct access rights and the repository exists.</code></pre><p>发现在/c/Users/Administrator/.ssh/文件夹中没有know_hosts文件，执行</p><pre><code>$ ssh git@github.com</code></pre><p>我输入这条命令后，文件夹中就会出现know_hosts文件，并且hexo d成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久没有更新博客了，昨天写了点东西，hexo d的时候却出错了，不能部署。今天终于解决了，在这里记录一下。&lt;/p&gt;
&lt;p&gt;遇到的第一个问题，hexo d的时候，出现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fatal: could not read Username for &amp;ap
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu相关问题</title>
    <link href="http://yoursite.com/2018/06/30/Ubuntu%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/06/30/Ubuntu相关问题/</id>
    <published>2018-06-30T14:04:58.000Z</published>
    <updated>2018-06-30T15:05:02.553Z</updated>
    
    <content type="html"><![CDATA[<p>1、安装Ubuntu虚拟机时，内存需设置为主机内存的1/3，否则容易电脑卡死。</p><p>2、当执行spt-get安装时，出现“无法定位软件包”的提示时，输入：</p><pre><code>sudo apt-get update</code></pre><p>3、当出现无法获得锁 /var/lib/apt/lists/lock - open(11:资源暂时不可用)，输入：</p><pre><code>sudo rm /var/lib/apt/lists/locksudo rm /var/lib/dpkg/lock</code></pre><p>4、实现虚拟机与win主机之间粘贴复制</p><p><a href="https://blog.csdn.net/teacher20133/article/details/54601816" target="_blank" rel="external">https://blog.csdn.net/teacher20133/article/details/54601816</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、安装Ubuntu虚拟机时，内存需设置为主机内存的1/3，否则容易电脑卡死。&lt;/p&gt;
&lt;p&gt;2、当执行spt-get安装时，出现“无法定位软件包”的提示时，输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3、当
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://yoursite.com/2017/06/29/%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/06/29/算法/</id>
    <published>2017-06-29T07:44:00.000Z</published>
    <updated>2017-12-01T04:25:29.947Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>算法原理：<br>选择一个起始点V作为当前节点</p><p>1、访问当前节点，并标注为已访问，到下一步</p><p>2、如果存在和当前节点相邻并且还没有被访问的节点U，则将U设为当前节点，返回上一步</p><p>3、如果当前节点没有未被访问的相邻节点，则回溯，回退到上一个当前节点</p><p>上面所说的当前节点用栈来维护，每次访问到的节点入栈，回溯的时候出栈</p><p>伪代码：</p><pre><code>DFS（V）    visited[v] = true;    dosomething(v);    for u in adjecnt_list[v]        if visited[u] == false            DFS(u)</code></pre><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>选择一个起点v放入先进先出队列中</p><p>1、如果队列不为空，弹出队列首元素作为当前节点，执行下一步；如果队列为空，则算法结束</p><p>2、将与当前节点相邻且未被访问的所有节点信息更新，并全部放入队列，继续执行上一步</p><p>伪代码：</p><pre><code>BFS(v):    resetArray(visited,false);    visted[v] = true;    queue.push(v);    while(!queue.isEmpty()){        v = queue.poll();        for u in adjecent_list[v]:            if(visited[u] == false)                dosomething(u);                queue.push(u);    }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;DFS&quot;&gt;&lt;a href=&quot;#DFS&quot; class=&quot;headerlink&quot; title=&quot;DFS&quot;&gt;&lt;/a&gt;DFS&lt;/h3&gt;&lt;p&gt;算法原理：&lt;br&gt;选择一个起始点V作为当前节点&lt;/p&gt;
&lt;p&gt;1、访问当前节点，并标注为已访问，到下一步&lt;/p&gt;
&lt;p&gt;2、如果存在
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-MVC学习笔记</title>
    <link href="http://yoursite.com/2017/06/27/Spring-MVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/06/27/Spring-MVC学习笔记/</id>
    <published>2017-06-27T11:10:05.000Z</published>
    <updated>2017-12-01T04:16:20.728Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-MVC执行流程"><a href="#Spring-MVC执行流程" class="headerlink" title="Spring-MVC执行流程"></a>Spring-MVC执行流程</h3><ol><li>客户端发起request请求</li><li>请求到前端控制器（DispatcherServlet）</li><li>前端控制器请求HandlerMapping根据请求的URL查找Handler</li><li>处理器映射器（HandlerMapping）向前端控制器返回Handler</li><li>前端控制器调用处理器适配器去执行Handler</li><li>处理器适配器（HandlerAdapter）执行Handler，就是平常所说的controler执行</li><li>Handler执行完以后给HandlerAdapter返回ModelAndView</li><li>处理器适配器向前端控制器返回ModelAndView</li><li>前端控制器请求视图解析器（view resolver）进行视图解析</li><li>由视图解析器根据ModelAndView得到实际的view对象，向前端控制器返回view</li><li>前端控制器进行视图渲染，将模型数据填充到request域中</li><li>前端控制器向用户响应结果</li></ol><h3 id="spring-MVC是什么？"><a href="#spring-MVC是什么？" class="headerlink" title="spring-MVC是什么？"></a>spring-MVC是什么？</h3><p>MVC是一种设计模式，通过分离模型、视图与控制器在应用程序中的角色将业务逻辑从界面中解耦。spring-MVC是spring的一个重要模块，它以强大的IOC容器为基础，充分利用容器的特性来简化配置。</p><h3 id="拦截器（Interceptor）"><a href="#拦截器（Interceptor）" class="headerlink" title="拦截器（Interceptor）"></a>拦截器（Interceptor）</h3><p>Spring-MVC中的拦截器相当于JavaEE中的过滤器，用于拦截用户的请求并进行相应的处理。</p><p>如何使用拦截器呢？</p><p>首先是实现HandlerInterceptor接口，然后实现afterCompletion、postHandle、preHandle三个抽象方法，最后再springMVC-servlet.xml中添加拦截器配置。</p><p>1、afterCompletion：在整个视图渲染完毕之后执行方法里面的内容，主要用于释放一些资源</p><p>2、postHandle：在Controller执行之后，视图渲染之前执行方法里面的内容，也就是说postHandle方法可以对Model进行操作</p><p>3、preHandle：在Controller执行之前，执行方法里面的内容，注意该方法是有返回值的，当方法返回false时整个请求就结束了</p><h3 id="springMVC配置"><a href="#springMVC配置" class="headerlink" title="springMVC配置"></a>springMVC配置</h3><p>通过maven创建web工程时，自动创建的web.xml中的文件头中用的servlet版本为2.3，需修改为3.1<br><br>web.xml的3.1版头文件可以在B:\tomcat_9\apache-tomcat-8.0.43\webapps\examples\WEB-INF\web.xml中去复制，也就是到Tomcat的安装路径中去找</p><p>首先是在web.xml中配置前端控制器</p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;          &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;          &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>然后创建springmvc-servlet.xml，配置视图解析器和包扫描</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-4.0.xsd     http://www.springframework.org/schema/mvc     http://www.springframework.org/schema/mvc/spring-mvc.xsd     http://www.springframework.org/schema/context     http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 配置springMVC --&gt;    &lt;!-- 1.开启springMVC注解模式 --&gt;    &lt;mvc:annotation-driven /&gt;    &lt;!--2.静态资源默认servlet配置--&gt;    &lt;!--            1).加入对静态资源处理：js,gif,png            2).允许使用 &quot;/&quot; 做整体映射    --&gt;    &lt;mvc:default-servlet-handler/&gt;    &lt;!--3：配置JSP 显示ViewResolver--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;       &lt;/bean&gt;    &lt;!--4:扫描web相关的bean--&gt;    &lt;context:component-scan base-package=&quot;org.seckill.web&quot;/&gt;&lt;/beans&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring-MVC执行流程&quot;&gt;&lt;a href=&quot;#Spring-MVC执行流程&quot; class=&quot;headerlink&quot; title=&quot;Spring-MVC执行流程&quot;&gt;&lt;/a&gt;Spring-MVC执行流程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;客户端发起request请求&lt;/
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>悲观锁与乐观锁</title>
    <link href="http://yoursite.com/2017/06/26/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/"/>
    <id>http://yoursite.com/2017/06/26/悲观锁与乐观锁/</id>
    <published>2017-06-26T08:27:15.000Z</published>
    <updated>2017-12-01T04:24:40.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库层面的悲观锁与乐观锁"><a href="#数据库层面的悲观锁与乐观锁" class="headerlink" title="数据库层面的悲观锁与乐观锁"></a>数据库层面的悲观锁与乐观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>数据库中，<strong>悲观并发控制</strong>是一种并发控制的方法，这种方法简称是悲观锁。它可以阻止一个事物以影响其他用户的方式来修改数据。如果一个事物的某个操作应用了锁，那只有这个事物把锁释放时，其他事物才能够执行与该锁冲突的操作。</p><p>主要应用于数据争用激烈的场合，以及发生并发冲突时使用锁保护数据的成本低于事物回滚成本的环境中。</p><p>悲观锁实际上是采用了“先取锁再访问”的保守策略，使数据处理更加安全，但是，这样就增加了数据库的开销，而且还有死锁的可能。并且在只读操作中，是不需要加锁的，盲目的加锁只会增加系统的负载。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a><span style="font-family:Comic Sans MS">乐观锁</span></h3><p>乐观锁的全称是乐观并发控制，也是一种并发控制方法。它假设多用户并发的事物在实际操作时不会彼此影响，各个事物能够在不加锁的情况下处理各自影响的那部分数据。</p><p>在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</p><p>可以发现，悲观锁是通过加锁实现并发控制，乐观锁是通过回滚实现并发控制。</p><p>应用场景：与悲观锁正好相反，乐观并发控制多数用于数据争用不大、冲突较少的环境中，这种环境中，偶尔回滚事务的成本会低于读取数据时锁定数据的成本，因此可以获得比其他并发控制方法更高的吞吐量。</p><p>虽然乐观锁减少了数据库的开销和系统的负载，也不会产生死锁，但还是会发生不可预期的结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库层面的悲观锁与乐观锁&quot;&gt;&lt;a href=&quot;#数据库层面的悲观锁与乐观锁&quot; class=&quot;headerlink&quot; title=&quot;数据库层面的悲观锁与乐观锁&quot;&gt;&lt;/a&gt;数据库层面的悲观锁与乐观锁&lt;/h2&gt;&lt;h3 id=&quot;悲观锁&quot;&gt;&lt;a href=&quot;#悲观锁&quot; c
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java杂记</title>
    <link href="http://yoursite.com/2017/06/21/Java%E6%9D%82%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/06/21/Java杂记/</id>
    <published>2017-06-21T14:42:04.000Z</published>
    <updated>2017-12-01T04:20:28.944Z</updated>
    
    <content type="html"><![CDATA[<p><strong>java进制转换：</strong></p><ul><li>java的整型封装类Integer和Long提供<strong>toString（int i,int radix）</strong>静态方法，可以将一个任意进制的整数转换为其他进制的整数。</li><li>使用Integer或Long的<strong>toBinaryString</strong>方法将整数转换为二进制。</li><li>使用Integer或Long的<strong>toOctalString</strong>方法将整数转换为八进制。</li><li>使用Integer或Long的<strong>toHexString</strong>方法将整数转换为十六进制。</li><li>使用Integer或Long的<strong>toString(int i)</strong>方法可以将其他进制的整数转换为十进制的整数的字符串表示</li></ul><h3 id="String类可以继承吗"><a href="#String类可以继承吗" class="headerlink" title="String类可以继承吗"></a>String类可以继承吗</h3><p>String类是被final修饰的，所以不可以被继承；</p><p>为什么要用final修饰String呢？</p><p>1、<strong>Security</strong>: the system can hand out sensitive bits of read-only information without worrying that they will be altered</p><p>2、<strong>Performance</strong>: immutable data is very useful in making things thread-safe.</p><h3 id="String-相关问题"><a href="#String-相关问题" class="headerlink" title="String 相关问题"></a>String 相关问题</h3><p>1、“==”是用来检测俩引用是不是指向内存中的同一个对象，而equals()方法则检测的是两个对象的值是否相等</p><p>2、String、StringBuffer和StringBuilder:</p><ul><li>都是final类，都不允许被继承</li><li>String的长度时不可变的，其它两个的长度是可变的。String是不可变的对象, 因此在每次对String 类型进行改变的时候，都会生成一个<strong>新的 String 对象</strong>，然后将<strong>指针</strong>指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后，JVM 的 GC 就会开始工作，性能就会降低。</li><li>StringBuffer是线程安全的，StringBuilder是线程不安全的</li></ul><p>使用基本原则：如果只是操作少量数据，使用String；如果单线程操作大量数据，选用StringBuilder;如果多线程操作大量数据，选用StringBuffer。</p><p>3、如何使用空格分割字符串：</p><pre><code>String[] strArray = aString.split(&quot;\\s+&quot;);</code></pre><p>4、String c = new String(“java”);这个语句背后的发生过程：</p><ul><li>1）在heap上为String对象申请内存</li><li>2）尝试从常量池中获取“java”字符串，如果常量池中不存在，则在常量池中新建“java”字符串，并返回</li><li>3）调用构造方法，初始化String对象</li></ul><p>java中String对象使用char数组存储字符串，变量c指向Java堆的String对象，且该对象的char数组指向常量池的”java”字符串。</p><p><img src="http://incdn1.b0.upaiyun.com/2016/09/dca37659a4da9a595fe59232a0278414.png" alt=""></p><pre><code>String a = &quot;hello &quot;;String b = &quot;world&quot;;String c = a + b; //字符串变量的连接动作，在编译阶段会被转化成StringBuilder的append操作，变量c最终指向Java堆上新建String对象String d = &quot;hello world&quot;;//变量d指向常量池的”hello world”字符串，所以 c != d。</code></pre><p><a href="http://www.importnew.com/21711.html" target="_blank" rel="external">浅谈java String内幕（上）</a><br><br><a href="http://www.importnew.com/21720.html" target="_blank" rel="external">String.intern()原理</a></p><h3 id="synchronized与ReentrantLock"><a href="#synchronized与ReentrantLock" class="headerlink" title="synchronized与ReentrantLock"></a>synchronized与ReentrantLock</h3><p>ReentrantLock在加锁和提供内存可见性上的功能与内置锁相同。但是，ReentrantLock还有一些其他更灵活的加锁功能，如可定时锁，轮询锁，可中断锁，公平锁和非公平锁，实现非块结构的加锁。其中，定时锁与轮询锁由tryLock()方法实现。可中断锁由lockInterruptibly()方法实现，公平锁与非公平锁可由ReentrantLock的构造函数实现。</p><p>在高并发环境中，ReentrantLock的性能优于内置锁。</p><p>既然ReentrantLock锁这么好，那为什么java还不弃用内置锁呢？</p><p>原因是：内置锁为许多开发人员所熟悉，并且简洁紧凑。ReentrantLock则有一定的危险性，如果在finally块中忘记调用unlock（）方法，则会产生一些潜在的危险。仅当内置锁无法满足需求时，才可以考虑使用ReentrantLock。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;java进制转换：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;java的整型封装类Integer和Long提供&lt;strong&gt;toString（int i,int radix）&lt;/strong&gt;静态方法，可以将一个任意进制的整数转换为其他进制的整数。&lt;/l
      
    
    </summary>
    
      <category term="语法" scheme="http://yoursite.com/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>多线程学习笔记</title>
    <link href="http://yoursite.com/2017/06/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/06/21/多线程学习笔记/</id>
    <published>2017-06-21T14:40:47.000Z</published>
    <updated>2017-12-01T04:23:43.840Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Executor、ExecutorService和Executors"><a href="#Executor、ExecutorService和Executors" class="headerlink" title="Executor、ExecutorService和Executors"></a>Executor、ExecutorService和Executors</h3><p>A：Executor是一个抽象层面的核心接口，将任务的提交过程和执行过程解耦。</p><p>B：ExecutorService对executor接口进行了扩展，添加了一些用于生命周期管理的方法，如返回future对象，终止、关闭线程池等方法。</p><p>A与B的区别：</p><p>1、B是A的子接口</p><p>2、A定义execute（）方法来接收Runnable接口的对象，<br>   B中的submit方法可以接受runnable接口和callable接口的对象</p><p>3、execute方法不返回任何结果，<br>   submit方法可以通过future对象返回运算结果</p><p>4、B提供了管理线程池的方法</p><p>Executors是一个工具类，提供工厂方法来创建不同类型的线程池</p><hr><h3 id="如何正确的停止一个线程："><a href="#如何正确的停止一个线程：" class="headerlink" title="如何正确的停止一个线程："></a>如何正确的停止一个线程：</h3><ul><li>Thread.stop或Thread.susupend(已废弃)</li><li>使用interupt()方法</li><li>使用条件变量</li></ul><p>具体见：</p><blockquote><p><a href="http://ibruce.info/2013/12/19/how-to-stop-a-java-thread/" target="_blank" rel="external">http://ibruce.info/2013/12/19/how-to-stop-a-java-thread/</a></p></blockquote><h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><ol><li>线程是进程的子集，一个进程可以有多个线程，每条线程并行执行不同的任务</li><li>不同的进程拥有不同的内存空间，而所有的线程共享同一块内存空间</li><li>每个线程都有单独的栈内存来存储本地数据</li><li>线程是操作系统能够进行运算调度的最小单位，它被包含在进程中，是进程的实际运作单位</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Executor、ExecutorService和Executors&quot;&gt;&lt;a href=&quot;#Executor、ExecutorService和Executors&quot; class=&quot;headerlink&quot; title=&quot;Executor、ExecutorService
      
    
    </summary>
    
      <category term="语法" scheme="http://yoursite.com/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>B树与B+树</title>
    <link href="http://yoursite.com/2017/06/17/B%E6%A0%91%E4%B8%8EB-%E6%A0%91/"/>
    <id>http://yoursite.com/2017/06/17/B树与B-树/</id>
    <published>2017-06-17T08:47:40.000Z</published>
    <updated>2017-12-01T04:17:08.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="B树与B-树的区别"><a href="#B树与B-树的区别" class="headerlink" title="B树与B+树的区别"></a>B树与B+树的区别</h2><p>B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。</p><p>B+树非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中</p><h3 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h3><p>B+树的内部节点不含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。</p><p>B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。</p><h3 id="B树的优点"><a href="#B树的优点" class="headerlink" title="B树的优点"></a>B树的优点</h3><p>由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;B树与B-树的区别&quot;&gt;&lt;a href=&quot;#B树与B-树的区别&quot; class=&quot;headerlink&quot; title=&quot;B树与B+树的区别&quot;&gt;&lt;/a&gt;B树与B+树的区别&lt;/h2&gt;&lt;p&gt;B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据库索引</title>
    <link href="http://yoursite.com/2017/06/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2017/06/17/数据库索引/</id>
    <published>2017-06-17T06:33:58.000Z</published>
    <updated>2017-12-01T04:23:27.149Z</updated>
    
    <content type="html"><![CDATA[<p>索引是存储引擎用于快速找到记录的一种数据结构。</p><h2 id="索引目的"><a href="#索引目的" class="headerlink" title="索引目的"></a>索引目的</h2><p>索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql</p><h2 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h2><h3 id="索引类别"><a href="#索引类别" class="headerlink" title="索引类别"></a>索引类别</h3><ul><li><p>大多数索引指的是B-树索引，InnoDB索引使用的数据结构是B+Tree</p></li><li><p>MySQL中的MEMORY存储引擎显示支持哈希索引，哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效，存储引擎会对所有的索引列计算一个哈希码，哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。如果哈希值发生冲突，哈希索引会以链表的方式存储多个记录指针到同一个哈希条目中</p></li><li><p>空间数据索引：MyISAM存储引擎支持，无需前缀查询，会从所有维度来索引数据。</p></li></ul><h3 id="磁盘I-O与预读"><a href="#磁盘I-O与预读" class="headerlink" title="磁盘I/O与预读"></a>磁盘I/O与预读</h3><p>磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分：</p><ul><li>寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；</li><li>旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；</li><li>传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。</li></ul><p>那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。</p><p>考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)，也就是读取一页内的数据时候，实际上才发生了一次IO</p><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>B+树是B树的一种变种，B树是一个节点可以拥有超过2个子节点的二叉查找树。</p><p><img src="http://tech.meituan.com/img/mysql_index/btree.jpg" alt=""></p><p>如上图所示，浅蓝色是磁盘块，深蓝色代表数据项，黄色代表指针</p><p>叶子节点存储真实的数据，非叶子节点只存储指引方向的数据项。如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。</p><p>查找过程：</p><p>如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO；</p><p>在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO；</p><p>29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO；</p><p>真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p><h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><ol><li>索引大大减少了服务器需要扫描的数据量</li><li>帮助服务器避免排序和临时表</li><li>可以将随机I/O变为顺序I/O</li></ol><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><p>唯一的索引 (Unique Index)：在表格上面创建某个一个唯一的索引。唯一的索引意味着两个行不能拥有相同的索引值。</p><pre><code>CREATE UNIQUE INDEX 索引名称 ON 表名称 (列名称) </code></pre><p>列名称规定需要索引的列</p><p>简单索引：省略UNIQUE值，这样就可以使用重复的值</p><p>实例：</p><pre><code>CREATE INDEX PersonIndex ON Person (LastName)//索引不止一列时，使用逗号隔开列名CREATE INDEX PersonIndex ON Person (LastName, FirstName)</code></pre><p>参考：</p><blockquote><p><a href="http://tech.meituan.com/mysql-index.html" target="_blank" rel="external">http://tech.meituan.com/mysql-index.html</a></p><p><a href="http://blog.jobbole.com/24006/" target="_blank" rel="external">http://blog.jobbole.com/24006/</a></p></blockquote><hr><h2 id="索引分类："><a href="#索引分类：" class="headerlink" title="索引分类："></a>索引分类：</h2><p>普通索引：创建普通索引时，没有任何限制条件</p><p>唯一性索引：使用UNIQUE关键字创建，主键就是一种特殊的唯一性索引</p><p>全文索引：FULLTEXT，只能创建在CHAR、VARCHAR或TEXT类型的字段上。只有MyISAM存储引擎支持全文检索</p><p>单列索引：在表中的单个字段上创建索引</p><p>多列索引：在表的多个字段创建一个索引</p><p>空间索引：使用SPATIAL参数，空间索引只能建立在空间数据类型上，只有MyISAM存储引擎支持，且索引字段必须非空。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;索引是存储引擎用于快速找到记录的一种数据结构。&lt;/p&gt;
&lt;h2 id=&quot;索引目的&quot;&gt;&lt;a href=&quot;#索引目的&quot; class=&quot;headerlink&quot; title=&quot;索引目的&quot;&gt;&lt;/a&gt;索引目的&lt;/h2&gt;&lt;p&gt;索引的目的在于提高查询效率，可以类比字典，如果要查“mysql
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记</title>
    <link href="http://yoursite.com/2017/06/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/06/14/数据库学习笔记/</id>
    <published>2017-06-14T14:32:30.000Z</published>
    <updated>2017-12-01T04:25:13.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h2><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h3><p>原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。</p><h3 id="2-一致性"><a href="#2-一致性" class="headerlink" title="2.一致性"></a>2.一致性</h3><p>一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</p><h3 id="3-隔离性"><a href="#3-隔离性" class="headerlink" title="3.隔离性"></a>3.隔离性</h3><p>多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</p><p>事务之间的相互影响分为几种，分别为：脏读，不可重复读，幻读，丢失更新</p><p>(1)脏读</p><p>脏读意味着一个事务读取了另一个事务未提交的数据，而这个数据是有可能回滚的</p><p>(2)不可重复读</p><p>不可重复读意味着，在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。</p><p>(3)幻读（虚读）</p><p>幻读，是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.</p><p>(4)丢失更新</p><p>两个事务同时读取同一条记录，A先修改记录，B也修改记录（B是不知道A修改过），B提交数据后B的修改结果覆盖了A的修改结果。</p><h3 id="4-持久性"><a href="#4-持久性" class="headerlink" title="4.持久性"></a>4.持久性</h3><p>持久性，意味着在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p><h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><p><span style="font-family: comic sans ms,sans-serif;"><span style="color: red;">MySQL索引使用的数据结构是B+tree，Oracle及Sysbase的索引使用的是B-Tree</span></span></p><p>索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构</p><ul><li>索引加快数据库的检索速度</li><li>索引降低了插入、删除、修改等维护任务的速度</li><li>唯一索引可以确保每一行数据的唯一性</li><li>索引需要占物理和数据空间</li></ul><h2 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h2><p>事物是并发控制的基本单位</p><p>所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。</p><h2 id="drop、delete与truncate"><a href="#drop、delete与truncate" class="headerlink" title="drop、delete与truncate"></a>drop、delete与truncate</h2><ul><li>速度,一般来说: drop&gt; truncate &gt;delete </li><li>delete和truncate只删除表的数据不删除表的结构</li><li>不再需要一张表的时候，用drop</li><li>删除部分数据行时候，用delete，并且带上where子句</li><li>保留表而删除所有数据的时候用truncate</li></ul><h2 id="超键、候选键、主键、外键"><a href="#超键、候选键、主键、外键" class="headerlink" title="超键、候选键、主键、外键"></a>超键、候选键、主键、外键</h2><p>主键（PRIMARY KEY）：主键必须包含唯一的值，主键列不能包含null值，每个表都应该有一个主键，每个表都只能有一个主键</p><p>在创建表的时候创建主键约束：</p><pre><code>CREATETABLE Persons(    Id_P int NOT NULL,  //声明为主键的列不能有NULL值    LastName varchar(255) NOT NULL,    FirstName varchar(255),    Address varchar(255),    City varchar(255),    PRIMARY KEY (Id_P))//如果在表已存在的情况下为 &quot;Id_P&quot; 列创建 PRIMARY KEY 约束，请使用下面的 SQL：ALTER TABLE Persons ADD PRIMARY KEY (Id_P)//撤销 PRIMARY KEY 约束，请使用下面的 SQLALTER TABLE Persons DROP PRIMARY KEY</code></pre><p>外键：在一个表中存在的另一个表的主键称此表的外键</p><p><a href="http://blog.csdn.net/lfsfxy9/article/details/5949632" target="_blank" rel="external">理解超键、候选键、主键.</a></p><hr><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p><strong>视图既可以由数据库中1个或多个基本表导出，也可以由已存在的视图导出</strong></p><p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查三种操作，视图通常是一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p><p>创建视图：</p><pre><code>CREATE VIEW view_name ASSELECT column_name(s)FROM table_nameWHERE condition</code></pre><p>使用场景：</p><ul><li>当为了安全考虑时，只想要暴露表中的部分字段，这是就可以建一个视图</li><li>查询的数据来源于不同的表，希望以统一的方式查询，这时可以通过建一个视图把多个表的查询结果联合起来，查询者就只需要直接从视图中获取数据即可</li></ul><hr><h2 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h2><p>什么是存储引擎？</p><p>简而言之，存储引擎就是指表的类型，数据库的存储引擎决定了表在计算机中的存储方式。</p><h3 id="InnoDB引擎："><a href="#InnoDB引擎：" class="headerlink" title="InnoDB引擎："></a>InnoDB引擎：</h3><p>优势：提供了良好的事务管理、崩溃修复能力和并发控制，支持外键（FOREIGN KEY）和自增列(AUTO_INCREMENT)</p><p>缺点：读写效率差，占用的数据空间相对较大</p><p>应用场景：对事物完整性的要求较高，要求实现并发控制，需要频繁的更新、删除操作</p><h3 id="MyISAM存储引擎："><a href="#MyISAM存储引擎：" class="headerlink" title="MyISAM存储引擎："></a>MyISAM存储引擎：</h3><p>这种引擎的表存储为三种类型：frm，MYD，MYI，分别存储表的结构，表中数据和表的索引。</p><p>优点：占用空间小，插入数据快</p><p>缺点：不支持事物的完整性和并发性</p><p>应用场景：插入和读出操作频繁</p><h3 id="MEMORY存储引擎："><a href="#MEMORY存储引擎：" class="headerlink" title="MEMORY存储引擎："></a>MEMORY存储引擎：</h3><p>默认使用哈希索引，所有数据都在内存中，使用内存中的内容创建表</p><p>优点：数据处理速度快，</p><p>缺点：安全性不高，数据易丢失，生命周期短，</p><p>适用于创建小型表</p><h3 id="ARCHIVE存储引擎"><a href="#ARCHIVE存储引擎" class="headerlink" title="ARCHIVE存储引擎"></a>ARCHIVE存储引擎</h3><p>拥有很好的压缩机制，仅支持最基本的插入和查询两种功能</p><h3 id="CSV存储引擎"><a href="#CSV存储引擎" class="headerlink" title="CSV存储引擎"></a>CSV存储引擎</h3><p>把数据以逗号分隔的格式存储在文本文件中。</p><h3 id="BLACKHOLE存储引擎"><a href="#BLACKHOLE存储引擎" class="headerlink" title="BLACKHOLE存储引擎"></a>BLACKHOLE存储引擎</h3><p>接受但不存储数据，并且检索总是返回一个空集</p><h3 id="FEDERATED存储引擎"><a href="#FEDERATED存储引擎" class="headerlink" title="FEDERATED存储引擎"></a>FEDERATED存储引擎</h3><p>把数据存在远程数据库中</p><hr><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><strong>DISTINCT</strong> 用于返回唯一不同的值</p><p>MySQL中<strong>BETWEEN</strong>的边界问题：两边都包含，相当于&gt;=和&lt;=</p><p><strong>LIKE</strong>关键字可以匹配字符串是否相等，“%”可以代表任意长度的字符串，“_”只能表示单个字符。在实际使用时，需要匹配的字符串需要加引号，既可以是单引号，也可以是双引号</p><p>连接查询：将两个或两个以上的表按照某个条件连接起来，从中选取需要的数据。<br>分为内连接和外连接，外连接又有左连接和右连接。</p><ul><li>INNER JOIN: 如果表中有至少一个匹配，则返回行</li><li>LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行</li><li>RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行</li><li>FULL JOIN: 只要其中一个表中存在匹配，就返回行</li></ul><hr><h2 id="数据库的四种隔离级别"><a href="#数据库的四种隔离级别" class="headerlink" title="数据库的四种隔离级别"></a>数据库的四种隔离级别</h2><p>在数据库操作中，为了保证并发读取数据的正确性，提出了事物隔离级别概念</p><ul><li>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</li><li>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)</li><li>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读</li><li>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li></ul><h3 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h3><p>为什么需要范式？范式有什么作用？</p><p>范式可以减少数据冗余、消除异常、让数据组织更加和谐。</p><p>数据冗余是指一个字段在多个表中重复出现</p><p>什么是范式？</p><p>范式是为了消除重复数据，减少冗余数据，让数据库中的数据更好的一种组织，让磁盘空间得到有效利用的一种标准化组织</p><p>什么是第一范式？</p><p>第一范式就是每一个属性都不可再分。不符合第一范式则不能称为关系数据库。</p><p>什么是第二范式?</p><p>表中的属性必须完全依赖于全部主键，而不是部分主键.所以只有一个主键的表如果符合第一范式，那一定是第二范式。</p><p>第三范式：3NF是为了消除数据库中关键字之间的依赖关系</p><p>还有BC范式和第四范式。</p><p><a href="http://blog.jobbole.com/92442/" target="_blank" rel="external">参考资料1</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ACID特性&quot;&gt;&lt;a href=&quot;#ACID特性&quot; class=&quot;headerlink&quot; title=&quot;ACID特性&quot;&gt;&lt;/a&gt;ACID特性&lt;/h2&gt;&lt;h3 id=&quot;1-原子性&quot;&gt;&lt;a href=&quot;#1-原子性&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>JSTL学习笔记</title>
    <link href="http://yoursite.com/2017/06/14/JSTL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/06/14/JSTL学习笔记/</id>
    <published>2017-06-14T14:31:56.000Z</published>
    <updated>2017-12-01T04:22:46.877Z</updated>
    
    <content type="html"><![CDATA[<p>JSTL是java中的一个定制标记库集,全称为JSP Standard Tag Library。</p><h3 id="为什么要是用JSTL？"><a href="#为什么要是用JSTL？" class="headerlink" title="为什么要是用JSTL？"></a>为什么要是用JSTL？</h3><p>1、实现了JSP页面中的代码复用</p><p>2、书写JSP页面时可读性更强</p><p><strong>在JSP页面中使用JSTL标记时，需要添加下面这个指令</strong></p><pre><code>&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;&lt;c:out value=&quot;输出内容&quot;&gt;&lt;/c:out&gt; //核心库Ps：在uri中之所以能找到该http，是因为导入了jar，否则是找不到的。prefix=&quot;c&quot;，里面的名字可以自定义，一般为“c”。</code></pre><p><c:out>标签属于核心库</c:out></p><p>JSTL总共有6个标签库，分别是核心库、格式化库、数据库标签库、XML库、函数库、TLV</p><p>JSTL标签的value属性的属性值可以为变量和常量.</p><p>变量需要通过EL表达式来获取.</p><hr><h3 id="什么是EL表达式"><a href="#什么是EL表达式" class="headerlink" title="什么是EL表达式"></a>什么是EL表达式</h3><p>全名为Exoression Language</p><p>经常与JSTL配合使用，使得JSP页面更直观，写法更简单</p><p>普通写法：</p><pre><code>`&lt;%=session.getValue(&quot;name&quot;) %&gt;`</code></pre><p>EL表达式：</p><pre><code>&lt;c:out value=&quot;${sessionScope.name}&quot;/&gt;</code></pre><h3 id="EL表达式的格式"><a href="#EL表达式的格式" class="headerlink" title="EL表达式的格式"></a>EL表达式的格式</h3><p>用美元符号”$”定界,内容包括在花括号”{}”中; <strong>${表达式}</strong></p><p>EL表达式的基本格式：用美元符号“$”定界，内容包括在花括号“{}”中——${表达式}。</p><p><strong>EL表达式中的”.”与”[]”运算符：</strong></p><pre><code>通常情况两者通用，eg:${user.sex}等同于${user[&quot;sex&quot;]}；其中&quot;[]&quot;还可以用来进行集合元素中的定位${booklist[0].price}。</code></pre><p><strong>不通用的情况：</strong></p><p>1、包含特殊符号：</p><p>如${user.first-name}则为错误的写法，正确的：${user[“first-name”]}；</p><p>2、通过变量动态的取值时：${user[param]}—param可以是name or sex or others，是用户传入的情况。</p><p>而”.”不能动态取值，它的写法是：${user.name}or${user.sex}or…</p><h3 id="EL变量"><a href="#EL变量" class="headerlink" title="EL变量"></a>EL变量</h3><p>JSP内置对象  || EL变量范围</p><p>pagerequest || pageScope</p><p>request     || requestScope </p><p>session     || sessionScope</p><p>application || applicationScope</p><pre><code>&lt;c:out value=&quot;${username}&quot; /&gt;</code></pre><p>运行时，会依次在page-&gt;session-&gt;request-&gt;application范围中寻找名为username的变量，然后输出其值。但是如果没有，就返回空字符串。</p><h3 id="EL自动类型转换"><a href="#EL自动类型转换" class="headerlink" title="EL自动类型转换"></a>EL自动类型转换</h3><p>要取得文本框中的输入，我们需要做类型转换</p><p>普通写法：</p><pre><code>String str_count = request.getParameter(&quot;count&quot;);int count = Integer.parseInt(str_count);count = count + 20;</code></pre><p>EL会进行自动类型转换，只需要这样写：</p><pre><code>${param.count +20}</code></pre><p><img src="http://img.mukewang.com/5941e12a00012f7312800720.jpg" alt=""></p><p><img src="http://img.mukewang.com/58a7c49400018d8d12800720.jpg" alt=""></p><h3 id="c-out-标签"><a href="#c-out-标签" class="headerlink" title="c:out 标签"></a>c:out 标签</h3><pre><code>&lt;!-- 1、使用out标签输出常量 --&gt;&lt;c:out value=&quot;慕课网&quot; &gt;&lt;/c:out&gt;&lt;hr&gt;&lt;!-- 2、使用out标签输出变量 --&gt;&lt;!-- 直接输出变量 --&gt;&lt;%session.setAttribute(&quot;name&quot;, &quot;Bob&quot;); %&gt;&lt;c:out value=&quot;${name}&quot;&gt;&lt;/c:out&gt;&lt;hr&gt;&lt;!-- 3、当变量不存在时，通过default属性输出默认值 --&gt;&lt;c:out value=&quot;${name1}&quot; default=&quot;error&quot;&gt;&lt;/c:out&gt;&lt;hr&gt;&lt;!-- 4、设置输出转义后的字符需要escapeXml属性值设置成false，escapeXml默认值：true --&gt;&lt;c:out value=&quot;&lt;out标签&gt;&quot; escapeXml=&quot;false&quot;&gt;&lt;/c:out&gt;</code></pre><h3 id="c-set-标签"><a href="#c-set-标签" class="headerlink" title="c:set 标签"></a>c:set 标签</h3><pre><code>&lt;!-- 第一种写法 --&gt;&lt;c:set value=&quot;today&quot; var=&quot;day&quot; scope=&quot;session&quot;&gt;&lt;/c:set&gt;&lt;c:out value=&quot;${day}&quot;&gt;&lt;/c:out&gt;</code></pre><p><hr><br>    <!-- 第二种写法 --><br>    <c:set var="age" scope="application">four</c:set><br>    <c:out value="${age}"></c:out></p><p><hr><br>    <!-- 通过set标签向person中赋值 --><br>    <jsp:usebean id="person" class="entity.Persion"></jsp:usebean><br>    //将Javabean实例化为person<br>    <c:set target="${person}" property="user" value="admin"></c:set><br>    <c:out value="${person.user}"></c:out></p><p><hr><br>    <c:set target="${person}" property="pwd">123456</c:set><br>    <c:out value="${person.pwd}"></c:out></p><p>Ps：不能同时有“var”和“target”属性。“scope” 是可选的，如果没有使用这个属性，则默认为页面作用域。</p><h3 id="c-remove-标签"><a href="#c-remove-标签" class="headerlink" title="c:remove 标签"></a>c:remove 标签</h3><pre><code>&lt;c:set var=&quot;lastName&quot; value=&quot;Bob&quot; &gt;&lt;/c:set&gt;&lt;c:out value=&quot;${lastName}&quot;&gt;&lt;/c:out&gt;&lt;c:set var=&quot;firstName&quot; value=&quot;Jack&quot; &gt;&lt;/c:set&gt;&lt;c:remove var=&quot;firstName&quot;&gt;&lt;/c:remove&gt;&lt;c:out value=&quot;${firstName}&quot;&gt;&lt;/c:out&gt;</code></pre><p>Ps：remove的对象只能是某一个变量，不能是一个jsp:useBean中的某一个属性。</p><h3 id="c-catch-标签"><a href="#c-catch-标签" class="headerlink" title="c:catch 标签"></a>c:catch 标签</h3><p>catch标签中可以包含哪些容易出错的JSTL标签(逻辑)</p><pre><code>`&lt;c:catch var=&quot;error&quot;&gt;    //如果这段出错，错误信息将保存到error变量中    &lt;c:set target=&quot;aa&quot; property=&quot;bb&quot;&gt;asasa&lt;/c:set&gt; &lt;/c:catch&gt;&lt;c:out value=&quot;${error}&quot;&gt;&lt;/c:out&gt; //输出error，即输出错误信息`</code></pre><h3 id="c-if-标签"><a href="#c-if-标签" class="headerlink" title="c:if 标签"></a>c:if 标签</h3><pre><code>`//先构建一个表单&lt;form action=&quot;index.jsp&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;score&quot; value=&quot;${param.score}&quot; /&gt;    &lt;input type=&quot;submit&quot;/&gt; //这是一个提交按钮&lt;/form&gt;&lt;!-- 优秀：score&gt;=90 --&gt;&lt;c:if test=&quot;${param.score&gt;=90}&quot; var=&quot;result&quot; scope=&quot;session&quot;&gt;    &lt;c:out value=&quot;你的成绩：优秀——${sessionScope.result}&quot;&gt;&lt;/c:out&gt;&lt;/c:if&gt;`</code></pre><p>Ps：$(param.user)相当于&lt;%=request.getParameter(“user”)%&gt;；$(paramValues.favorites[0])相当于&lt;%=request.getParameters(“favorites”)[0]%&gt;。</p><h3 id="choose-when-otherwise标签"><a href="#choose-when-otherwise标签" class="headerlink" title="choose-when-otherwise标签"></a>choose-when-otherwise标签</h3><p>通常这三个标签被放在一起配合使用</p><p><c:choose>标签嵌套在<c:when>和<c:otherwise>标签外面作为他们的父标签来使用</c:otherwise></c:when></c:choose></p><p>其中choose和when标签也可以一起组合使用</p><pre><code>`&lt;c:choose&gt;    &lt;c:when test=&quot;${param.score&lt;=100 &amp;&amp; param.score&gt;=60 }&quot;&gt;        &lt;c:out value=&quot;及格&quot;&gt;&lt;/c:out&gt;    &lt;/c:when&gt;    &lt;c:when test=&quot;${param.score&lt;60 &amp;&amp; param.score&gt;=0 }&quot;&gt;        &lt;c:out value=&quot;不及格&quot;&gt;&lt;/c:out&gt;    &lt;/c:when&gt;    &lt;c:otherwise&gt;        &lt;c:out value=&quot;请检查你的输入！&quot;&gt;&lt;/c:out&gt;    &lt;/c:otherwise&gt;&lt;/c:choose&gt;`</code></pre><h3 id="foreach-标签"><a href="#foreach-标签" class="headerlink" title="foreach 标签"></a>foreach 标签</h3><p>-根据循环条件遍历集合（Collectoin）中的元素</p><ul><li>var设定变量名用于存储从集合中取出元素（必须无默认值）</li><li>items指定要遍历的集合(必须无默认值)</li><li>begin、end用于指定遍历的起始位置和终止位置(有默认)</li><li>step指定循环的步长(有默认)</li><li>varStatus通过index、count、first、last几个状态值，描述begin和end子集中的元素状态<br><hr><br>  `&lt;%<pre><code>List&lt;String&gt; fruits=new ArrayList&lt;String&gt;();fruits.add(&quot;apple&quot;);fruits.add(&quot;pear&quot;);fruits.add(&quot;orange&quot;);fruits.add(&quot;banana&quot;);request.setAttribute(&quot;fruits&quot;, fruits);</code></pre>  %&gt;<code>&lt;hr&gt;</code><!-- forEach标签用法 -->  <!-- 用法一：全部遍历 -->  <c:foreach var="fruit" items="${fruits}"><pre><code>&lt;c:out value=&quot;${fruit}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;</code></pre>  </c:foreach><code>&lt;hr&gt;</code><!-- 用法二：部分遍历 --><br>  <c:foreach var="fruit" items="${fruits}" begin="1" end="2"><pre><code>&lt;c:out value=&quot;${fruit}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;</code></pre>  </c:foreach><code>&lt;hr&gt;</code><!-- 用法三：部分遍历并带步长 --><br>   <c:foreach var="fruit" items="${fruits}" begin="1" end="3" step="2"><pre><code>&lt;c:out value=&quot;${fruit}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;</code></pre>   </c:foreach>`</li></ul><p>Ps：step默认值：1。</p><p><hr><br>    <code>&lt;!-- 用法四：部分遍历并带状态 --&gt;     &lt;c:forEach var=&quot;fruit&quot; items=&quot;${fruits}&quot; begin=&quot;1&quot; end=&quot;3&quot; varStatus=&quot;fru&quot;&gt;         &lt;c:out value=&quot;${fruit}——四个属性：&quot;&gt;&lt;/c:out&gt;&lt;br&gt;         &lt;c:out value=&quot;index属性：${fru.index}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;         &lt;c:out value=&quot;count属性：${fru.count}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;         &lt;c:out value=&quot;first属性：${fru.first}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;         &lt;c:out value=&quot;last属性：${fru.last}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;         &lt;c:out value=&quot;----------&quot;&gt;&lt;/c:out&gt;&lt;br&gt;     &lt;/c:forEach&gt;</code></p><p>Ps：index从0开始；count从1开始；first是否第一个（boolean）；last是否最后一个（boolean）。</p><h3 id="forTokens-标签"><a href="#forTokens-标签" class="headerlink" title="forTokens 标签"></a>forTokens 标签</h3><pre><code>&lt;c:forTokens items=&quot;400-888888-123&quot; delims=&quot;-&quot; var=&quot;num&quot;&gt;     &lt;c:out value=&quot;${num}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;&lt;/c:forTokens&gt;</code></pre><h3 id="import标签"><a href="#import标签" class="headerlink" title="import标签"></a>import标签</h3><p>语法格式：</p><pre><code>&lt;c:import url=&quot;&quot; context=&quot;&quot; var=&quot;&quot; scope=&quot;&quot; charEncoding=&quot;&quot; varReader=&quot;&quot;&gt;&lt;/c:import&gt;</code></pre><ul><li>.url被导入资源的URL路径</li><li>.context相同服务器下其他的web工程，必须以”/“开头</li><li>.var以String类型存入北包含文件的内容</li><li>.Scope var变量的JSP范围</li><li>.charEncoding被导入文件的编码格式</li><li>.varReader以Reader类型存储被包含文件内容</li></ul><hr><pre><code>`&lt;!-- 导入网络上的绝对路径 --&gt;&lt;c:catch var=&quot;error0&quot;&gt;    &lt;c:import url=&quot;http://www.imooc.com&quot;&gt;&lt;/c:import&gt;&lt;/c:catch&gt;&lt;c:out value=&quot;${error0}&quot;&gt;&lt;/c:out&gt;`</code></pre><p><hr><br>     `<!-- 导入相对路径文件 --><br>     <c:catch var="error1"><br>         <c:import url="Test.txt" charencoding="gbk"></c:import><br>     </c:catch></p><pre><code>&lt;c:out value=&quot;${error1}&quot;&gt;&lt;/c:out&gt;`</code></pre><p>Ps：由于可能网络中断导致抛出异常，所以常常把import标签放在catch标签里。</p><h3 id="redirect标签"><a href="#redirect标签" class="headerlink" title="redirect标签"></a>redirect标签</h3><ul><li>-该标签用来实现请求的重定向，同时可以在url中加入指定的参数</li><li>.url指定重定向页面的地址，可以是一个string类型的绝对地址或相对地址</li><li>.context用于导入其他web应用中的页面<br><hr><pre><code>@temp.jspusername:&lt;c:out value=&quot;${param.username}&quot;&gt;&lt;/c:out&gt;password:&lt;c:out value=&quot;${param.password}&quot;&gt;&lt;/c:out&gt;</code></pre><hr><pre><code>@index.jsp&lt;!-- redirect标签用法 --&gt; &lt;c:redirect url=&quot;temp.jsp&quot;&gt;     &lt;c:param name=&quot;username&quot;&gt;Lily&lt;/c:param&gt;     &lt;c:param name=&quot;password&quot;&gt;123456&lt;/c:param&gt; &lt;/c:redirect&gt;</code></pre></li></ul><h2 id="JSTL函数"><a href="#JSTL函数" class="headerlink" title="JSTL函数"></a>JSTL函数</h2><pre><code>&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;//使用JSTL函数时要有这句&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/functions&quot; prefix=&quot;fn&quot;%&gt;&lt;c:out value=&quot;“Hello World”字符串中是否包含“Hello”？${fn:contains(&apos;Hello World&apos;,&apos;Hello&apos;)}&quot;&gt;&lt;/c:out&gt;  &lt;c:out value=&quot;“Hello World”字符串中是否包含“ABCD”？${fn:contains(&apos;Hello World&apos;,&apos;ABCD&apos;)}&quot;&gt;&lt;/c:out&gt;  &lt;c:out value=&quot;“Hello World”字符串中是否包含“hello”（忽略大小写）？${fn:containsIgnoreCase(&apos;Hello World&apos;,&apos;hello&apos;)}&quot;&gt;&lt;/c:out&gt;  &lt;c:out value=&quot;“Hello”是否在“Hello World”字符串开头？${fn:startsWith(&apos;Hello World&apos;,&apos;Hello&apos;)}&quot;&gt;&lt;/c:out&gt;  &lt;c:out value=&quot;“world”是否在“Hello World”字符串尾部？${fn:endsWith(&apos;Hello World&apos;,&apos;world&apos;)}&quot;&gt;&lt;/c:out&gt;</code></pre><p><hr><br>    <!-- 不会输出<book>标签 --><br>      <!-- 可输出标签但会出现转义问题 --><br>      <c:out value="${fn:escapeXml('<book>书</book>')}"></c:out><br>      <hr><br>      <!-- 可输出标签且不会出现转义问题 --><br>      <c:out value="<book>书</book>"></c:out><br>      <hr><br>      <!-- indexOf函数用法 --><br>      <c:out value="“Hello World”字符串“llo”出现的index值：${fn:indexOf('Hello World','llo')}"></c:out></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JSTL是java中的一个定制标记库集,全称为JSP Standard Tag Library。&lt;/p&gt;
&lt;h3 id=&quot;为什么要是用JSTL？&quot;&gt;&lt;a href=&quot;#为什么要是用JSTL？&quot; class=&quot;headerlink&quot; title=&quot;为什么要是用JSTL？&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="语法" scheme="http://yoursite.com/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="JSTL" scheme="http://yoursite.com/tags/JSTL/"/>
    
  </entry>
  
  <entry>
    <title>阿里文娱面试题</title>
    <link href="http://yoursite.com/2017/06/13/%E9%98%BF%E9%87%8C%E6%96%87%E5%A8%B1%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2017/06/13/阿里文娱面试题/</id>
    <published>2017-06-13T02:08:56.000Z</published>
    <updated>2017-12-01T04:25:01.681Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java中的8种基本数据类型"><a href="#Java中的8种基本数据类型" class="headerlink" title="Java中的8种基本数据类型"></a>Java中的8种基本数据类型</h3><p>类型：二进制位数，所占字节（1字节=8bit位），数据范围</p><p>byte：8位，1字节，最大存储数据量是255，存放的数据范围是-128~127之间。</p><p>short：16位，2字节，最大数据存储量是65536，数据范围是-32768~32767之间。</p><p>int：32位，4字节，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。</p><p>long：64位，8字节，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。</p><p>float：32位，4字节，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。</p><p>double：64位，8字节，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。</p><p>boolean：1位，1字节，只有true和false两个取值。</p><p>char：16位，2字节，存储Unicode码，用单引号赋值。</p><h3 id="汉字可以转换为char吗？"><a href="#汉字可以转换为char吗？" class="headerlink" title="汉字可以转换为char吗？"></a>汉字可以转换为char吗？</h3><p>可以！</p><p>char是按照字符存储的，不管英文还是中文，固定占用占用2个字节，用来储存Unicode字符。范围在0-65536。unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。</p><p>Unicode（统一码、万国码、单一码）是一种在计算机上使用的字符编码。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。</p><p>###数据库中的数据类型 ###</p><p><strong>数值类型</strong></p><table><tbody><tr><th width="10%">类型</th><th width="15%"><br>大小</th><th width="30%">范围（有符号）</th><th width="30%">范围（无符号）<br></th><th width="15%">用途</th></tr><tr><td>TINYINT</td><td>1 字节</td><td>(-128，127)</td><td>(0，255)</td><td>小整数值</td><br></tr><br><tr><br><td><br>SMALLINT<br></td><br><td><br>2 字节<br></td><br><td><br>(-32 768，32 767)<br></td><br><td><br>(0，65 535)<br></td><br><td><br>大整数值<br></td><br></tr><br><tr><br><td><br>MEDIUMINT<br></td><br><td><br>3 字节<br></td><br><td><br>(-8 388 608，8 388 607)<br></td><br><td><br>(0，16 777 215)<br></td><br><td><br>大整数值<br></td><br></tr><br><tr><br><td><br>INT或INTEGER<br></td><br><td><br>4 字节<br></td><br><td><br>(-2 147 483 648，2 147 483 647)<br></td><br><td><br>(0，4 294 967 295)<br></td><br><td><br>大整数值<br></td><br></tr><br><tr><br><td><br>BIGINT<br></td><br><td><br>8 字节<br></td><br><td><br>(-9 233 372 036 854 775 808，9 223 372 036 854 775 807)<br></td><br><td><br>(0，18 446 744 073 709 551 615)<br></td><br><td><br>极大整数值<br></td><br></tr><br><tr><br><td><br>FLOAT<br></td><br><td><br>4 字节<br></td><br><td><br>(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)<br></td><br><td><br>0，(1.175 494 351 E-38，3.402 823 466 E+38)<br></td><br><td><br>单精度<br>浮点数值<br></td><br></tr><br><tr><br><td><br>DOUBLE<br></td><br><td><br>8 字节<br></td><br><td><br>(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)<br></td><br><td><br>0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)<br></td><br><td><br>双精度<br>浮点数值<br></td><br></tr><br><tr><br><td><br>DECIMAL<br></td><br><td><br>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2<br></td><br><td><br>依赖于M和D的值<br></td><br><td><br>依赖于M和D的值<br></td><br><td><br>小数值<br></td><br></tr><br></tbody><br></table><br><strong>日期和时间类型</strong><br><table><br><tbody><br><tr><br><th width="10%"><br>类型<br></th><br><th width="10%"><br>大小<br>(字节)<br></th><br><th width="40%"><br>范围<br></th><br><th width="20%"><br>格式<br></th><br><th><br>用途<br></th><br></tr><br><tr><br><td width="10%"><br>DATE<br></td><br><td width="10%"><br>3<br></td><br><td><br>1000-01-01/9999-12-31<br></td><br><td><br>YYYY-MM-DD<br></td><br><td><br>日期值<br></td><br></tr><br><tr><br><td width="10%"><br>TIME<br></td><br><td width="10%"><br>3<br></td><br><td><br>‘-838:59:59’/‘838:59:59’<br></td><br><td><br>HH:MM:SS<br></td><br><td><br>时间值或持续时间<br></td><br></tr><br><tr><br><td width="10%"><br>YEAR<br></td><br><td width="10%"><br>1<br></td><br><td><br>1901/2155<br></td><br><td><br>YYYY<br></td><br><td><br>年份值<br></td><br></tr><br><tr><br><td width="10%"><br>DATETIME<br></td><br><td width="10%"><br>8<br></td><br><td width="40%"><br>1000-01-01 00:00:00/9999-12-31 23:59:59<br></td><br><td><br>YYYY-MM-DD HH:MM:SS<br></td><br><td><br>混合日期和时间值<br></td><br></tr><br><tr><br><td width="10%"><br>TIMESTAMP<br></td><br><td width="10%"><br>4<br></td><br><td width="40%"><br>1970-01-01 00:00:00/2037 年某时<br></td><br><td><br>YYYYMMDD HHMMSS<br></td><br><td><br>混合日期和时间值，时间戳<br></td><br></tr><br></tbody><br></table><br><strong>字符串类型</strong><br><table class="reference"><br><tbody><br><tr><br><th width="20%"><br>类型<br></th><br><th width="25%"><br>大小<br></th><br><th width="55%"><br>用途<br></th><br></tr><br><tr><br><td><br>CHAR<br></td><br><td><br>0-255字节<br></td><br><td><br>定长字符串<br></td><br></tr><br><tr><br><td><br>VARCHAR<br></td><br><td><br>0-65535 字节<br></td><br><td><br>变长字符串<br></td><br></tr><br><tr><br><td><br>TINYBLOB<br></td><br><td><br>0-255字节<br></td><br><td><br>不超过 255 个字符的二进制字符串<br></td><br></tr><br><tr><br><td><br>TINYTEXT<br></td><br><td><br>0-255字节<br></td><br><td><br>短文本字符串<br></td><br></tr><br><tr><br><td><br>BLOB<br></td><br><td><br>0-65 535字节<br></td><br><td><br>二进制形式的长文本数据<br></td><br></tr><br><tr><br><td><br>TEXT<br></td><br><td><br>0-65 535字节<br></td><br><td><br>长文本数据<br></td><br></tr><br><tr><br><td><br>MEDIUMBLOB<br></td><br><td><br>0-16 777 215字节<br></td><br><td><br>二进制形式的中等长度文本数据<br></td><br></tr><br><tr><br><td><br>MEDIUMTEXT<br></td><br><td><br>0-16 777 215字节<br></td><br><td><br>中等长度文本数据<br></td><br></tr><br><tr><br><td><br>LONGBLOB<br></td><br><td><br>0-4 294 967 295字节<br></td><br><td><br>二进制形式的极大文本数据<br></td><br></tr><br><tr><br><td><br>LONGTEXT<br></td><br><td><br>0-4 294 967 295字节<br></td><br><td><br>极大文本数据<br></td><br></tr><br></tbody><br></table><blockquote><p><a href="http://www.runoob.com/mysql/mysql-data-types.html" target="_blank" rel="external">http://www.runoob.com/mysql/mysql-data-types.html</a></p></blockquote><h3 id="java与javac的区别"><a href="#java与javac的区别" class="headerlink" title="java与javac的区别"></a>java与javac的区别</h3><p>1，javac命令用来编译java文件，例如编写一个Test.java文件，使用javac Test.java可以执行编译操作，将生成一个Test.class文件。</p><p>2，java命令可以执行生成的class文件，使用java Test可以执行编写的代码。</p><h3 id="如何在cmd编译Java程序时倒入其他包？"><a href="#如何在cmd编译Java程序时倒入其他包？" class="headerlink" title="如何在cmd编译Java程序时倒入其他包？"></a>如何在cmd编译Java程序时倒入其他包？</h3><blockquote><p><a href="https://benweizhu.github.io/blog/2014/04/07/write-java-code-without-ide/" target="_blank" rel="external">https://benweizhu.github.io/blog/2014/04/07/write-java-code-without-ide/</a></p></blockquote><h3 id="java中如何将一个字符转换为ascii码"><a href="#java中如何将一个字符转换为ascii码" class="headerlink" title="java中如何将一个字符转换为ascii码"></a>java中如何将一个字符转换为ascii码</h3><p>方法1：</p><pre><code>char   c   =   &apos;a &apos;； byte   b   =(byte)c；</code></pre><p>方法2：</p><pre><code>直接将这个字符转化为int型就可以得到ascii码值char c   =   &apos;a &apos;； int  b   =   c； //字符的ascii码值 </code></pre><p>同理将一个ascii码转换为相应的字符：</p><p>   例如：字符a</p><pre><code>int d = 97;    char e = (char)d;</code></pre><h3 id="Java中的进制转换"><a href="#Java中的进制转换" class="headerlink" title="Java中的进制转换"></a>Java中的进制转换</h3><p>1）十进制转成十六进制：</p><p>Integer.toHexString(int i) </p><p>2）十进制转成八进制 </p><p>Integer.toOctalString(int i) </p><p>3）十进制转成二进制 </p><p>Integer.toBinaryString(int i)</p><p>4）十六进制转成十进制 </p><p>Integer.valueOf(“FFFF”,16).toString() </p><p>5）八进制转成十进制 </p><p>Integer.valueOf(“876”,8).toString() </p><p>6）二进制转十进制 </p><p>Integer.valueOf(“0101”,2).toString() </p><p>7）有什么方法可以直接将2,8,16进制直接转换为10进制的吗? </p><p>java.lang.Integer类 </p><p>parseInt(String s, int radix) </p><h3 id="“-java比较文件内容是否相同的方法”"><a href="#“-java比较文件内容是否相同的方法”" class="headerlink" title=" “ java比较文件内容是否相同的方法”"></a><a href="http://blog.csdn.net/very365_1208/article/details/8824033" target="_blank" rel="external"> “ java比较文件内容是否相同的方法”</a></h3><h3 id="MySQL数据库引擎"><a href="#MySQL数据库引擎" class="headerlink" title="MySQL数据库引擎"></a>MySQL数据库引擎</h3><p><a href="http://www.cnblogs.com/lina1006/archive/2011/04/29/2032894.html" target="_blank" rel="external">浅谈MySql的存储引擎（表类型）</a></p><p><a href="http://blog.csdn.net/souldak/article/details/10943835" target="_blank" rel="external">Mysql数据库引擎类型与特性对比</a></p><p>还有一些关于数据库如何写自增主键的问题，和数据结构的问题，这些需要详细复习，例如哈夫曼树，搜索所用的数据结构等，单词树就是trie树，这个也用于搜索引擎。</p><p>都是些非常非常基础的问题，其它的问题都知道，但就是回答的不是很好，记得不清楚，还需要复习。</p><p>面试官还说JSP中的对象等问题也要熟。总之，基础！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java中的8种基本数据类型&quot;&gt;&lt;a href=&quot;#Java中的8种基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;Java中的8种基本数据类型&quot;&gt;&lt;/a&gt;Java中的8种基本数据类型&lt;/h3&gt;&lt;p&gt;类型：二进制位数，所占字节（1字节=8bit
      
    
    </summary>
    
    
      <category term="其余" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BD%99/"/>
    
  </entry>
  
  <entry>
    <title>TCP</title>
    <link href="http://yoursite.com/2017/06/07/TCP/"/>
    <id>http://yoursite.com/2017/06/07/TCP/</id>
    <published>2017-06-07T06:19:50.000Z</published>
    <updated>2017-12-01T04:21:59.305Z</updated>
    
    <content type="html"><![CDATA[<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><strong>三次握手的目的</strong></p><p>同步连接双方的序列号和确认号并交换 TCP窗口大小信息</p><p><img src="http://img.blog.csdn.net/20161110145428358" alt=""></p><p><strong>1 第一次握手</strong>：建立连接。</p><p>客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</p><p><strong>2 第二次握手</strong>：服务器收到SYN报文段。</p><p>服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</p><p><strong>3 第三次握手</strong>：客户端收到服务器的SYN+ACK报文段。</p><p>然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p><h3 id="四次分手"><a href="#四次分手" class="headerlink" title="四次分手"></a>四次分手</h3><p>第一次分手：<strong>主机1</strong>（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，<strong>主机1</strong> 进入<font color="red"><strong>FIN _ WAIT_1</strong></font> 状态；这表示主机1没有数据要发送给主机2了；</p><p>第二次分手：<strong>主机2</strong>收到了<strong>主机1</strong>发送的FIN报文段，向<strong>主机1</strong>回一个ACK报文段，Acknowledgment Number为Sequence Number加1；<strong>主机1</strong>进入<font color="red"><strong>FIN_ WAIT_2</strong></font>状态；主机2告诉主机1，我“同意”你的关闭请求；</p><p>第三次分手：<strong>主机2</strong>向<strong>主机1</strong>发送FIN报文段，请求关闭连接，同时<strong>主机2</strong>进入<font color="blue"><strong>LAST_ACK</strong></font>状态；</p><p>第四次分手：<strong>主机1</strong>收到<strong>主机2</strong>发送的FIN报文段，向<strong>主机2</strong>发送ACK报文段，然后<strong>主机1</strong>进入<font color="blue"><strong>TIME_WAIT</strong></font>状态；<strong>主机2</strong>收到<strong>主机1</strong>的ACK报文段以后，就关闭连接；此时，<strong>主机1</strong> 等待<font color="red"><strong>2MSL</strong></font>后依然没有收到回复，则证明Server端已正常关闭，那好，<strong>主机1</strong>也可以关闭连接了。</p><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p><h3 id="为什么要四次分手"><a href="#为什么要四次分手" class="headerlink" title="为什么要四次分手"></a>为什么要四次分手</h3><p>当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；</p><p>但是，这个时候主机1还是可以接受来自主机2的数据；</p><p>当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；</p><p>当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接</p><h3 id="四次分手状态解释"><a href="#四次分手状态解释" class="headerlink" title="四次分手状态解释"></a>四次分手状态解释</h3><p><strong>FIN<em> WAIT</em> 1</strong>: 这个状态要好好解释一下，其实<strong>FIN<em> WAIT</em> 1</strong>和<strong>FIN<em> WAIT</em> 2</strong>状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：<strong>FIN<em> WAIT</em> 1</strong>状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到<strong>FIN<em> WAIT</em> 1</strong>状态。而当对方回应ACK报文后，则进入到<strong>FIN<em> WAIT</em> 2</strong>状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以<strong>FIN<em> WAIT</em> 1</strong>状态一般是比较难见到的，而<strong>FIN_ WAIT_2</strong>状态还有时常常可以用netstat看到。（主动方）</p><p><strong>FIN<em> WAIT</em> 2</strong>：上面已经详细解释了这种状态，实际上<strong>FIN_ WAIT_2</strong>状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）</p><p><strong>CLOSE_WAIT</strong>：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方）</p><p><strong>LAST_ACK</strong>: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）</p><p><strong>TIME_ WAIT</strong>: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME<em>WAIT状态，而无须经过**FIN </em> WAIT_ 2**状态。（主动方）</p><p><strong>CLOSED</strong>: 表示连接中断。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;三次握手&quot;&gt;&lt;a href=&quot;#三次握手&quot; class=&quot;headerlink&quot; title=&quot;三次握手&quot;&gt;&lt;/a&gt;三次握手&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;三次握手的目的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步连接双方的序列号和确认号并交换 TCP窗口大小信息&lt;/p
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>maven相关问题</title>
    <link href="http://yoursite.com/2017/06/06/maven%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/06/06/maven相关问题/</id>
    <published>2017-06-06T11:28:15.000Z</published>
    <updated>2017-12-01T04:22:12.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一次安装和使用maven"><a href="#第一次安装和使用maven" class="headerlink" title="第一次安装和使用maven"></a>第一次安装和使用maven</h2><p>第一，虽然eclipse for Java EE里面自带了maven的插件，但是这个插件的版本比较旧。最好还是在自己电脑上再装一次maven，然后在eclipse里面设置一下使用external maven。设置方法是：window -&gt; preference -&gt; maven -&gt; installations点击add按钮，选择maven安装的路径，然后把它勾选上。</p><p>第二，maven作为一个项目管理工具确实非常好用，但是在国内这个网络条件下实在是让人恼火。之前oschina的中央仓库可用，现在oschina的maven服务器关了，一直没找到国内镜像来替代。今天发现阿里云公开了一个中央仓库，大家可以试试。</p><p>修改maven根目录下的conf文件夹中的setting.xml文件，内容如下：</p><pre><code>&lt;mirrors&gt;    &lt;mirror&gt;          &lt;id&gt;alimaven&lt;/id&gt;          &lt;name&gt;aliyun maven&lt;/name&gt;          &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;          &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;            &lt;/mirror&gt;&lt;/mirrors&gt;</code></pre><p>第三，eclipse里面的maven插件m2eclipse有点问题，每次打开的时候都会去下载maven的索引文件。而这个索引文件非常大，下载速度又很慢，所以卡在Updating index central|<a href="http://repo1.maven.org/maven2这个地方。其实可以把这个关掉的。window" target="_blank" rel="external">http://repo1.maven.org/maven2这个地方。其实可以把这个关掉的。window</a> -&gt; preference -&gt; maven然后把download repository index updates on startup去掉即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一次安装和使用maven&quot;&gt;&lt;a href=&quot;#第一次安装和使用maven&quot; class=&quot;headerlink&quot; title=&quot;第一次安装和使用maven&quot;&gt;&lt;/a&gt;第一次安装和使用maven&lt;/h2&gt;&lt;p&gt;第一，虽然eclipse for Java EE里面
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>HTTP</title>
    <link href="http://yoursite.com/2017/06/06/HTTP/"/>
    <id>http://yoursite.com/2017/06/06/HTTP/</id>
    <published>2017-06-06T06:42:54.000Z</published>
    <updated>2017-12-01T04:20:11.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP请求GET和POST的区别"><a href="#HTTP请求GET和POST的区别" class="headerlink" title="HTTP请求GET和POST的区别"></a>HTTP请求GET和POST的区别</h2><p>1</p><p>GET提交：请求的数据会附在URL之后（就是把数据放置在HTTP协议头＜request-line＞中）</p><p>POST提交：把提交的数据放置在是HTTP包的包体＜request-body＞中</p><p>所以，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</p><p>2、传输数据的大小：<br>理论上URL和http对于大小没有限制，但是在实际环境中：</p><p>GET:特定浏览器和服务器对URL长度有限制</p><p>POST:由于不是通过URL传值，理论上数据不受限</p><p>3、在传递敏感信息时，POST的安全性要比GET的安全性高，浅层面上可以这样说，对于get方法，请求的参数我们可以直接在URL中看到，即在地址栏中看到。post方法的请求参数在消息体中，无法直接肉眼看见。但是如果对消息抓包的话，还是可以看见post中的请求参数的。安全性概念有很多方面，就看是怎么看了</p><p>4、GET 仅用来获取查看信息，不能改变服务器信息。POST 用来改变服务器信息</p><p>5、使用GET方法时，浏览器可能会缓存你的地址等信息，还会留下历史记录，而对于POST方法呢，则不会进行缓存</p><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>1xx：指示信息–表示请求已接收，继续处理。</p><p>2xx：成功–表示请求已被成功接收、理解、接受。</p><p>3xx：重定向–要完成请求必须进行更进一步的操作。</p><p>4xx：客户端错误–请求有语法错误或请求无法实现。</p><p>5xx：服务器端错误–服务器未能实现合法的请求。</p><p>常见状态代码：</p><p>200 OK：客户端请求成功。</p><p>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。</p><p>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</p><p>403 Forbidden：服务器收到请求，但是拒绝提供服务。</p><p>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</p><p>500 Internal Server Error：服务器发生不可预期的错误。</p><p>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。</p><h2 id="常见HTTP方法"><a href="#常见HTTP方法" class="headerlink" title="常见HTTP方法"></a>常见HTTP方法</h2><p><img src="http://images0.cnblogs.com/blog2015/776887/201507/031450517829255.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTTP请求GET和POST的区别&quot;&gt;&lt;a href=&quot;#HTTP请求GET和POST的区别&quot; class=&quot;headerlink&quot; title=&quot;HTTP请求GET和POST的区别&quot;&gt;&lt;/a&gt;HTTP请求GET和POST的区别&lt;/h2&gt;&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;G
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>&#39;equals与==的区别&#39;</title>
    <link href="http://yoursite.com/2017/06/02/equals%E4%B8%8E-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2017/06/02/equals与-的区别/</id>
    <published>2017-06-02T10:42:18.000Z</published>
    <updated>2017-12-01T04:18:46.217Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、"><a href="#1、" class="headerlink" title="1、 =="></a>1、 <strong>==</strong></h3><p>如果作用于基本数据类型的变量，则直接比较其存储的的“值”是否相等；</p><p>如果作用于引用类型的变量，则比较的是所指向的对象的地址</p><h3 id="2、equals"><a href="#2、equals" class="headerlink" title="2、equals"></a>2、equals</h3><p>注意：equals方法不能作用于基本数据类型</p><p>如果没有对equals方法重写，则比较的是引用类型的变量所指向的对象的地址</p><p>诸如String、Date等类对equals方法进行了重写，比较的是所指向的对象的内容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、&quot;&gt;&lt;a href=&quot;#1、&quot; class=&quot;headerlink&quot; title=&quot;1、 ==&quot;&gt;&lt;/a&gt;1、 &lt;strong&gt;==&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;如果作用于基本数据类型的变量，则直接比较其存储的的“值”是否相等；&lt;/p&gt;
&lt;p&gt;如果作用于引
      
    
    </summary>
    
      <category term="语法" scheme="http://yoursite.com/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>&#39;eclipse相关问题&#39;</title>
    <link href="http://yoursite.com/2017/06/02/eclipse%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/06/02/eclipse相关问题/</id>
    <published>2017-06-02T07:21:41.000Z</published>
    <updated>2017-12-01T04:17:30.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、-在Eclipse中显示-project和-classpath和-setting目录"><a href="#1、-在Eclipse中显示-project和-classpath和-setting目录" class="headerlink" title="1、 在Eclipse中显示.project和.classpath和.setting目录"></a>1、 在Eclipse中显示.project和.classpath和.setting目录</h3><p>选中工程，选择Filters</p><p><img src="http://img.blog.csdn.net/20141124115218046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZ2hhbnRvbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><p>取消.resources勾选，点击OK.显示.settings文件夹, .classpath 文件, .project文件, .gitignore文件</p><p><img src="http://img.blog.csdn.net/20141124115818232?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZ2hhbnRvbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><p>设置结束</p><h3 id="2、java项目下的bin文件夹不显示"><a href="#2、java项目下的bin文件夹不显示" class="headerlink" title="2、java项目下的bin文件夹不显示"></a>2、java项目下的bin文件夹不显示</h3><p>打开“Window”-“Show View”-“Navigator”就可以打开了</p><h3 id="3、Eclipse中设置在创建新类时自动生成注释"><a href="#3、Eclipse中设置在创建新类时自动生成注释" class="headerlink" title="3、Eclipse中设置在创建新类时自动生成注释"></a>3、Eclipse中设置在创建新类时自动生成注释</h3><p>windows–&gt;preference </p><p>Java–&gt;Code Style–&gt;Code Templates</p><p>code–&gt;new Java files </p><p>编辑它 </p><p>${filecomment} </p><p>${package_declaration}</p><pre><code>/** * @author 作者 E-mail: * @version 创建时间：${date} ${time} * 类说明 */</code></pre><p>${typecomment} </p><p>${type_declaration} </p><h3 id="4、在Eclipse中自动生成接口和JUnit测试类"><a href="#4、在Eclipse中自动生成接口和JUnit测试类" class="headerlink" title="4、在Eclipse中自动生成接口和JUnit测试类"></a>4、在Eclipse中自动生成接口和JUnit测试类</h3><p><a href="http://jingyan.baidu.com/article/ab69b270d63f572ca6189f51.html" target="_blank" rel="external">“百度经验”</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、-在Eclipse中显示-project和-classpath和-setting目录&quot;&gt;&lt;a href=&quot;#1、-在Eclipse中显示-project和-classpath和-setting目录&quot; class=&quot;headerlink&quot; title=&quot;1、 在
      
    
    </summary>
    
      <category term="IDE" scheme="http://yoursite.com/categories/IDE/"/>
    
    
      <category term="eclipse" scheme="http://yoursite.com/tags/eclipse/"/>
    
  </entry>
  
  <entry>
    <title>HashTable与HashMap的区别</title>
    <link href="http://yoursite.com/2017/05/31/HashTable%E4%B8%8EHashMap%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2017/05/31/HashTable与HashMap的区别/</id>
    <published>2017-05-31T14:05:37.000Z</published>
    <updated>2017-12-01T04:20:15.095Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、时间"><a href="#1、时间" class="headerlink" title="1、时间"></a>1、时间</h3><p>HT产生于JDK1.1，HM产生于JDK1.2</p><h3 id="2、作者"><a href="#2、作者" class="headerlink" title="2、作者"></a>2、作者</h3><p>HT是3个作者，HM是4个作者，多了个Doug Lea</p><h3 id="3、API"><a href="#3、API" class="headerlink" title="3、API"></a>3、API</h3><p>HashMap继承自抽象类AbstractMap</p><p>HashTable继承自抽象类Dictionary</p><p>HashMap在实现时对null做了特殊处理，将null的hashCode值定为了0，从而将其存放在哈希表的第0个bucket中。所以HashMap支持null键和null值</p><p>HashTable在遇到null时，会抛出NullPointerException异常</p><h3 id="4、实现原理"><a href="#4、实现原理" class="headerlink" title="4、实现原理"></a>4、实现原理</h3><p>HashMap/HashTable内部用Entry数组实现哈希表，而对于映射到同一个哈希桶（数组的同一个位置）的键值对，使用Entry链表来存储(解决hash冲突)。</p><p>HashTable默认的初始大小为11，之后每次扩充为原来的2n+1。</p><p>HashMap默认的初始化大小为16，之后每次扩充为原来的2倍。</p><h3 id="5、线程安全"><a href="#5、线程安全" class="headerlink" title="5、线程安全"></a>5、线程安全</h3><p>HashTable是同步的，HashMap不是</p><p>实现：公开的方法比如get都使用了synchronized描述符。而遍历视图比如keySet都使用了Collections.synchronizedXXX进行了同步包装</p><h3 id="6、推荐使用"><a href="#6、推荐使用" class="headerlink" title="6、推荐使用"></a>6、推荐使用</h3><p>如果你不需要线程安全，那么使用HashMap，如果需要线程安全，那么使用ConcurrentHashMap。HashTable已经被淘汰了，不要在新的代码中再使用它。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、时间&quot;&gt;&lt;a href=&quot;#1、时间&quot; class=&quot;headerlink&quot; title=&quot;1、时间&quot;&gt;&lt;/a&gt;1、时间&lt;/h3&gt;&lt;p&gt;HT产生于JDK1.1，HM产生于JDK1.2&lt;/p&gt;
&lt;h3 id=&quot;2、作者&quot;&gt;&lt;a href=&quot;#2、作者&quot; clas
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Hash" scheme="http://yoursite.com/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>Java语法糖</title>
    <link href="http://yoursite.com/2017/05/28/Java%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <id>http://yoursite.com/2017/05/28/Java语法糖/</id>
    <published>2017-05-28T12:30:40.000Z</published>
    <updated>2017-12-01T04:19:14.582Z</updated>
    
    <content type="html"><![CDATA[<p><strong>语法糖</strong></p><p>编译器实现的小把戏，编译期间以特定的字节码或者特定的方式对这些语法做一些处理，开发者就可以用了</p><p>这些方法不会为程序提供任何实质性的功能改进，但是他们可以提高性能，提升语法的严谨性，减少编码出错的机会</p><h2 id="可变长度参数"><a href="#可变长度参数" class="headerlink" title="可变长度参数"></a>可变长度参数</h2><p>1、可以使用遍历数组的方式去遍历可变参数</p><p>2、可变参数是利用数组实现的</p><p>3、可变长度参数必须作为方法参数列表中的最后一个参数</p><p>4、方法参数列表中只能有一个可变长度参数</p><h2 id="foreach循环遍历原理"><a href="#foreach循环遍历原理" class="headerlink" title="foreach循环遍历原理"></a>foreach循环遍历原理</h2><p>编译的时候编译器会自动将for这个关键字的使用转化为对目标的迭代器的使用，这就是foreach的循环原理</p><p>任何一个集合，不论是JDK提供的还是自己写的，只要想使用foreach循环遍历，就必须正确的实现iterable接口，这就是23种常用的设计模式中的迭代器模式。</p><p>如果不实现这个接口，那在集合中使用foreach遍历时就会报空指针异常</p><p>但是<strong>数组</strong>中并没有实现iterator接口，那为什么可以直接使用iterator接口？？？？后面详细了解了再更新</p><h2 id="自动拆箱和自动装箱"><a href="#自动拆箱和自动装箱" class="headerlink" title="自动拆箱和自动装箱"></a>自动拆箱和自动装箱</h2><p>Java为每种基本数据类型都提供了对应的包装器类型。例如：</p><pre><code>public class TestMain{   public static void main(String[] args)   {       Integer i = 10;    //自动根据数值创建对应的Integer对象，就是自动装箱   }}public class TestMain{   public static void main(String[] args)   {       Integer integer = 10;       int i = integer;   //根据包装器类型自动将数据转换为基本类型，这就是自动拆箱   }}</code></pre><p>原理：</p><p>自动装箱：Java虚拟机会自动调用Integer的valueOf方法</p><p>自动拆箱：Java虚拟机会自动调用Integer的intValue方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;语法糖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编译器实现的小把戏，编译期间以特定的字节码或者特定的方式对这些语法做一些处理，开发者就可以用了&lt;/p&gt;
&lt;p&gt;这些方法不会为程序提供任何实质性的功能改进，但是他们可以提高性能，提升语法的严谨性，减少编码出错的机会&lt;/p
      
    
    </summary>
    
      <category term="语法" scheme="http://yoursite.com/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
</feed>
